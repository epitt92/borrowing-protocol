{
  "language": "Solidity",
  "sources": {
    "contracts/APToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./mintable-token.sol\";\n\n/// @title implements minting/burning functionality for owner\ncontract APToken is MintableToken {\n  /// @dev address of the token, it is used to be swapped against in ArbitragePool\n  address public baseToken;\n\n  // solhint-disable-next-line func-visibility\n  constructor(\n    string memory name,\n    string memory symbol,\n    address _baseToken\n  ) MintableToken(name, symbol) {\n    baseToken = _baseToken;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/mintable-token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title implements minting/burning functionality for owner\ncontract MintableToken is ERC20, Ownable {\n  // solhint-disable-next-line func-visibility\n  constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n  /// @dev mints tokens to the recipient, to be called from owner\n  /// @param recipient address to mint\n  /// @param amount amount to be minted\n  function mint(address recipient, uint256 amount) public onlyOwner {\n    _mint(recipient, amount);\n  }\n\n  /// @dev burns token of specified amount from msg.sender\n  /// @param amount to burn\n  function burn(uint256 amount) public {\n    _burn(msg.sender, amount);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/arbitrage-pool-uniswap.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n//import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./interfaces/uniswap/IUniswapV3Router.sol\";\nimport \"./interfaces/ITroveFactory.sol\";\nimport \"./interfaces/IMintableToken.sol\";\nimport \"./APToken.sol\";\nimport \"./utils/BONQMath.sol\";\nimport \"./utils/constants.sol\";\n\n/// @title is used to liquidate troves and reward depositors with collateral redeemed\ncontract ArbitragePoolUniswap is UUPSUpgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable, Constants {\n  using BONQMath for uint256;\n  using SafeERC20 for IERC20;\n  using SafeERC20 for IERC20Metadata;\n\n  /// @dev stores APtoken address for each token\n  mapping(address => IMintableToken) public collateralToAPToken;\n  /// @dev stores totalDeposit + rewards value for each collateral\n  mapping(address => uint256) public depositsAndRewards;\n\n  ITroveFactory public immutable factory;\n  IUniswapV3Router public immutable router;\n\n  event Deposit(address _collateralToken, address _contributor, uint256 _amount, uint256 _apAmount);\n  event Withdraw(address _collateralToken, address _contributor, uint256 _amount, uint256 _apAmount);\n  event Arbitrage(address _collateralToken, address[] _path, uint256 _amountIn, uint256 _amountOut);\n  event APtokenDeployed(address _collateralToken, address _apToken);\n\n  // solhint-disable-next-line func-visibility\n  constructor(address _factory, address _router) {\n    require(_factory != address(0x0), \"55115b trove factory must not be address 0x0\");\n    require(_router != address(0x0), \"55115b router address must not be address 0x0\");\n    factory = ITroveFactory(_factory);\n    router = IUniswapV3Router(_router);\n    // to prevent contract implementation to be reinitialized by someone else\n    _disableInitializers();\n  }\n\n  function initialize() public initializer {\n    __Ownable_init();\n    __ReentrancyGuard_init();\n  }\n\n  /// @dev make the contract upgradeable by its owner\n  function _authorizeUpgrade(address) internal override onlyOwner {}\n\n  function name() public view virtual returns (string memory) {\n    return \"ArbitragePoolUniswap\";\n  }\n\n  /// @dev calculates the price of APtoken by baseToken/apToken.supply()\n  /// @param  _collateralToken IERC20 address of base token\n  /// @param  _apToken IMintableToken address of AP token\n  function _apTokenPrice(address _collateralToken, IMintableToken _apToken) internal view returns (uint256) {\n    uint256 colDepositAndRewards = depositsAndRewards[_collateralToken];\n    uint256 apSupply = _apToken.totalSupply();\n    if (colDepositAndRewards == 0 || apSupply == 0) return DECIMAL_PRECISION;\n    return (colDepositAndRewards * DECIMAL_PRECISION) / _apToken.totalSupply();\n  }\n\n  /// @dev calculates the price of APtoken by baseToken/apToken.supply()\n  /// @param  _collateralToken IERC20 address of base token\n  function getAPtokenPrice(address _collateralToken) external view returns (uint256) {\n    IMintableToken apToken = collateralToAPToken[_collateralToken];\n    return _apTokenPrice(_collateralToken, apToken);\n  }\n\n  /// @dev to deposit collateral into ArbitragePool and get APtoken\n  /// @param  _collateralToken amount to deposit\n  /// @param  _amount amount to deposit\n  function deposit(address _collateralToken, uint256 _amount) public nonReentrant {\n    IMintableToken apToken = collateralToAPToken[_collateralToken];\n    require(address(apToken) != address(0), \"d7db9 token must have APtoken\");\n    require(_amount > 0, \"d7db9 deposit amount must be bigger than zero\");\n\n    uint256 startPrice = _apTokenPrice(_collateralToken, apToken);\n    require(IERC20(_collateralToken).transferFrom(msg.sender, address(this), _amount), \"150aa0 transfer from failed\");\n    uint256 amountToMint = (_amount * DECIMAL_PRECISION) / startPrice;\n    apToken.mint(msg.sender, amountToMint);\n    depositsAndRewards[_collateralToken] += _amount;\n\n    emit Deposit(_collateralToken, msg.sender, _amount, amountToMint);\n  }\n\n  /// @dev to withdraw collateral from ArbitragePool by redeeming APtoken\n  /// @param  _collateralToken amount to withdraw\n  /// @param  _amount amount of APtoken to give\n  function withdraw(address _collateralToken, uint256 _amount) public nonReentrant {\n    IMintableToken apToken = collateralToAPToken[_collateralToken];\n    require(_amount > 0, \"3b329 withdrawal amount must be bigger than 0\");\n    // firstly transfer AP token, then calculating collateral amount\n    apToken.transferFrom(msg.sender, address(this), _amount);\n    uint256 amountOut = (_amount * _apTokenPrice(_collateralToken, apToken)) / DECIMAL_PRECISION;\n    // firstly burn AP token, decrease totalDeposit then transfer collateral\n    apToken.burn(_amount);\n    depositsAndRewards[_collateralToken] -= amountOut;\n    IERC20(_collateralToken).safeTransfer(msg.sender, amountOut);\n\n    emit Withdraw(_collateralToken, msg.sender, amountOut, _amount);\n  }\n\n  /// @dev to do arbitrage\n  /// @param  _collateralToken collateral token address\n  /// @param  _amountIn start amount\n  /// @param  _path calldata[]\n  function arbitrage(\n    address _collateralToken,\n    uint256 _amountIn,\n    address[] calldata _path,\n    uint24[] calldata _fees,\n    uint256 expiry\n  ) public nonReentrant {\n    require(_path[0] == _collateralToken, \"92852 must start with collateralToken\");\n    require(_path[_path.length - 1] == _collateralToken, \"92852 must end with _collateralToken\");\n    require(block.timestamp < expiry || expiry == 0, \"92852 too late\");\n\n    IERC20 collateralToken = IERC20(_collateralToken);\n    uint256 startBalance = collateralToken.balanceOf(address(this));\n    // the swap must yield at least 1 coin (in ETH parlance: 1 Wei) more than what was put in and the TX has 10 minutes to execute\n    IUniswapV3Router.ExactInputParams memory swapParams = IUniswapV3Router.ExactInputParams({\n      path: _constructUniswapPath(_path, _fees),\n      recipient: address(this),\n      amountIn: _amountIn,\n      amountOutMinimum: _amountIn + 1\n    });\n    router.exactInput(swapParams);\n    uint256 amountOut = collateralToken.balanceOf(address(this)) - startBalance;\n    depositsAndRewards[_collateralToken] += amountOut;\n\n    emit Arbitrage(_collateralToken, _path, _amountIn, amountOut);\n  }\n\n  function getArbitragePath(address[] calldata _path, uint24[] calldata _fees) public view returns (bytes memory) {\n    return _constructUniswapPath(_path, _fees);\n  }\n\n  /// @dev to add new supported collateral by deploying APtoken for it\n  /// @param  _collateralToken collateral to be added\n  function addToken(address _collateralToken) public {\n    require(address(collateralToAPToken[_collateralToken]) == address(0x0), \"ac342 the token has already been added\");\n    IERC20Metadata collateralToken = IERC20Metadata(_collateralToken);\n    string memory apTokenName = string(abi.encodePacked(\"APToken for \", collateralToken.name()));\n    string memory apTokenSymbol = string(abi.encodePacked(\"AP\", collateralToken.symbol()));\n    APToken newAPtoken = new APToken(apTokenName, apTokenSymbol, _collateralToken);\n    address newAPtokenAddress = address(newAPtoken);\n    collateralToAPToken[_collateralToken] = IMintableToken(newAPtokenAddress);\n    collateralToken.safeApprove(address(router), MAX_INT);\n\n    emit APtokenDeployed(_collateralToken, newAPtokenAddress);\n  }\n\n  /// @dev approves the list collateral tokens on Router to enable arbitrage,\n  /// should be called when the router was changed.\n  /// @param  _collateralTokens list of collateralToken addresses\n  function batchApproveRouter(address[] calldata _collateralTokens) public {\n    address routerAddress = address(router);\n    uint256 i;\n    for (i; i < _collateralTokens.length; i++) {\n      IERC20 collateralToken = IERC20(_collateralTokens[i]);\n      collateralToken.approve(routerAddress, MAX_INT);\n    }\n  }\n\n  /// @dev moves extra collateral that was sent by mistake to the contract from the balance\n  /// @param  _collateralToken collateralToken addresses\n  function transferExtraCollateral(\n    address _collateralToken,\n    address _recipient,\n    uint256 _amount\n  ) public onlyOwner {\n    IERC20 collateralToken = IERC20(_collateralToken);\n    uint256 colBalance = collateralToken.balanceOf(address(this));\n    uint256 colDepositAndRewards = depositsAndRewards[_collateralToken];\n    require(colBalance - colDepositAndRewards >= _amount, \"0aa4b amount must be < extra amount\");\n    collateralToken.safeTransfer(_recipient, _amount);\n  }\n\n  /// @dev constructs uniswap swap path from arrays of tokens and pool fees\n  /// @param  _path address[] of tokens\n  /// @param  _fees uint24[] of pool fees\n  function _constructUniswapPath(address[] memory _path, uint24[] memory _fees)\n    private\n    pure\n    returns (bytes memory pathBytesString)\n  {\n    pathBytesString = abi.encodePacked(_path[0]);\n    for (uint256 i = 0; i < _fees.length; i++) {\n      pathBytesString = abi.encodePacked(pathBytesString, _fees[i], _path[i + 1]);\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0-rc.2) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0-rc.2) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV3Router.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./callback/IUniswapV3SwapCallback.sol\";\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface IUniswapV3Router is IUniswapV3SwapCallback {\n  struct ExactInputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n    uint160 sqrtPriceLimitX96;\n  }\n\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\n  /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n  /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n  /// @return amountOut The amount of the received token\n  function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n  struct ExactInputParams {\n    bytes path;\n    address recipient;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n  }\n\n  /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n  /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n  /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n  /// @return amountOut The amount of the received token\n  function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n  struct ExactOutputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 amountOut;\n    uint256 amountInMaximum;\n    uint160 sqrtPriceLimitX96;\n  }\n\n  /// @notice Swaps as little as possible of one token for `amountOut` of another token\n  /// that may remain in the router after the swap.\n  /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n  /// @return amountIn The amount of the input token\n  function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n  struct ExactOutputParams {\n    bytes path;\n    address recipient;\n    uint256 amountOut;\n    uint256 amountInMaximum;\n  }\n\n  /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n  /// that may remain in the router after the swap.\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n  /// @return amountIn The amount of the input token\n  function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/ITroveFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IOwnable.sol\";\nimport \"./ITokenPriceFeed.sol\";\nimport \"./IMintableToken.sol\";\nimport \"./IMintableTokenOwner.sol\";\nimport \"./IFeeRecipient.sol\";\nimport \"./ILiquidationPool.sol\";\nimport \"./IStabilityPoolBase.sol\";\nimport \"./ITrove.sol\";\nimport \"./IServiceFeeGenerator.sol\";\n\ninterface ITroveFactory {\n  /* view */\n  function lastTrove(address _trove) external view returns (address);\n\n  function firstTrove(address _trove) external view returns (address);\n\n  function nextTrove(address _token, address _trove) external view returns (address);\n\n  function prevTrove(address _token, address _trove) external view returns (address);\n\n  function containsTrove(address _token, address _trove) external view returns (bool);\n\n  function stableCoin() external view returns (IMintableToken);\n\n  function bonqToken() external view returns (IERC20);\n\n  function tokenOwner() external view returns (IMintableTokenOwner);\n\n  function tokenToPriceFeed() external view returns (ITokenPriceFeed);\n\n  function feeRecipient() external view returns (IFeeRecipient);\n\n  function troveCount(address _token) external view returns (uint256);\n\n  function totalDebt() external view returns (uint256);\n\n  function maxTroveBONQStake() external view returns (uint256);\n\n  function getReducedFeeAndRefundAmount(uint256 _fee, address _trove)\n    external\n    view\n    returns (uint256 _reducedFee, uint256 _refundAmount);\n\n  function totalCollateral(address _token) external view returns (uint256);\n\n  function totalDebtForToken(address _token) external view returns (uint256);\n\n  function liquidationPool(address _token) external view returns (ILiquidationPool);\n\n  function stabilityPool() external view returns (IStabilityPoolBase);\n\n  function arbitragePool() external view returns (address);\n\n  function getRedemptionFeeRatio(address _trove) external view returns (uint256);\n\n  function getRedemptionFee(uint256 _feeRatio, uint256 _amount) external pure returns (uint256);\n\n  function getBorrowingFee(uint256 _amount) external view returns (uint256);\n\n  /* state changes*/\n  function createTrove(address _token) external returns (ITrove trove);\n\n  function createTroveAndBorrow(\n    address _token,\n    uint256 _collateralAmount,\n    address _recipient,\n    uint256 _borrowAmount,\n    address _nextTrove\n  ) external;\n\n  function removeTrove(address _token, address _trove) external;\n\n  function insertTrove(address _trove, address _newNextTrove) external;\n\n  function createNewServiceFee(\n    ITrove _trove,\n    uint256 _feeAmount,\n    uint256 _feeInterval\n  ) external returns (IServiceFeeGenerator newServiceFee);\n\n  function updateTotalCollateral(\n    address _token,\n    uint256 _amount,\n    bool _increase\n  ) external;\n\n  function updateTotalDebt(uint256 _amount, bool _borrow) external;\n\n  function setStabilityPool(address _stabilityPool) external;\n\n  function setArbitragePool(address _arbitragePool) external;\n\n  // solhint-disable-next-line var-name-mixedcase\n  function setWETH(address _WETH, address _liquidationPool) external;\n\n  function setMaxTroveBONQStake(uint256 _newAmount) external;\n\n  function increaseCollateralNative(address _trove, address _newNextTrove) external payable;\n\n  /* utils */\n  function emitLiquidationEvent(\n    address _token,\n    address _trove,\n    address stabilityPoolLiquidation,\n    uint256 collateral\n  ) external;\n\n  function emitTroveCollateralUpdate(\n    address _token,\n    uint256 _newAmount,\n    uint256 _newCollateralization\n  ) external;\n\n  function emitTroveDebtUpdate(\n    address _token,\n    uint256 _newAmount,\n    uint256 _newCollateralization,\n    uint256 _feePaid\n  ) external;\n}\n"
    },
    "contracts/interfaces/IMintableToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IOwnable.sol\";\n\ninterface IMintableToken is IERC20, IOwnable {\n  function mint(address recipient, uint256 amount) external;\n\n  function burn(uint256 amount) external;\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function approve(address spender, uint256 amount) external override returns (bool);\n}\n"
    },
    "contracts/utils/BONQMath.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n//import \"hardhat/console.sol\";\n\nlibrary BONQMath {\n  uint256 public constant DECIMAL_PRECISION = 1e18;\n  uint256 public constant MAX_INT = 2**256 - 1;\n\n  uint256 public constant MINUTE_DECAY_FACTOR = 999037758833783000;\n\n  /// @dev return the smaller of two numbers\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /// @dev return the bigger of two numbers\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Multiply two decimal numbers and use normal rounding rules:\n   *  -round product up if 19'th mantissa digit >= 5\n   *  -round product down if 19'th mantissa digit < 5\n   *\n   * Used only inside the exponentiation, _decPow().\n   */\n  function decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {\n    uint256 prod_xy = x * y;\n\n    decProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;\n  }\n\n  /**\n   * @dev Exponentiation function for 18-digit decimal base, and integer exponent n.\n   *\n   * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n   *\n   * Called by function that represent time in units of minutes:\n   * 1) IFeeRecipient.calcDecayedBaseRate\n   *\n   * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n   * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n   *\n   * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n   * negligibly different from just passing the cap, since:\n   * @param _base number to exponentially increase\n   * @param _minutes power in minutes passed\n   */\n  function _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint256) {\n    if (_minutes > 525600000) {\n      _minutes = 525600000;\n    } // cap to avoid overflow\n\n    if (_minutes == 0) {\n      return DECIMAL_PRECISION;\n    }\n\n    uint256 y = DECIMAL_PRECISION;\n    uint256 x = _base;\n    uint256 n = _minutes;\n\n    // Exponentiation-by-squaring\n    while (n > 1) {\n      if (n % 2 == 0) {\n        x = decMul(x, x);\n        n = n / 2;\n      } else {\n        // if (n % 2 != 0)\n        y = decMul(x, y);\n        x = decMul(x, x);\n        n = (n - 1) / 2;\n      }\n    }\n\n    return decMul(x, y);\n  }\n}\n"
    },
    "contracts/utils/constants.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Constants {\n  uint256 public constant DECIMAL_PRECISION = 1e18;\n  uint256 public constant LIQUIDATION_RESERVE = 1e18;\n  uint256 public constant MAX_INT = 2**256 - 1;\n\n  uint256 public constant PERCENT = (DECIMAL_PRECISION * 1) / 100; // 1%\n  uint256 public constant PERCENT10 = PERCENT * 10; // 10%\n  uint256 public constant PERCENT_05 = PERCENT / 2; // 0.5%\n  uint256 public constant BORROWING_RATE = PERCENT_05;\n  uint256 public constant MAX_BORROWING_RATE = (DECIMAL_PRECISION * 5) / 100; // 5%\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0-rc.2) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0-rc.2) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/uniswap/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.4;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/interfaces/IOwnable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IOwnable {\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() external view returns (address);\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) external;\n}\n"
    },
    "contracts/interfaces/ITokenPriceFeed.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IOwnable.sol\";\n\ninterface ITokenPriceFeed is IOwnable {\n  struct TokenInfo {\n    address priceFeed;\n    uint256 mcr;\n    uint256 mrf; // Maximum Redemption Fee\n  }\n\n  function tokenPriceFeed(address) external view returns (address);\n\n  function tokenPrice(address _token) external view returns (uint256);\n\n  function mcr(address _token) external view returns (uint256);\n\n  function mrf(address _token) external view returns (uint256);\n\n  function setTokenPriceFeed(\n    address _token,\n    address _priceFeed,\n    uint256 _mcr,\n    uint256 _maxRedemptionFeeBasisPoints\n  ) external;\n\n  function emitPriceUpdate(\n    address _token,\n    uint256 _priceAverage,\n    uint256 _pricePoint\n  ) external;\n\n  event NewTokenPriceFeed(address _token, address _priceFeed, string _name, string _symbol, uint256 _mcr, uint256 _mrf);\n  event PriceUpdate(address token, uint256 priceAverage, uint256 pricePoint);\n}\n"
    },
    "contracts/interfaces/IMintableTokenOwner.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IOwnable.sol\";\nimport \"./IMintableToken.sol\";\n\ninterface IMintableTokenOwner is IOwnable {\n  function token() external view returns (IMintableToken);\n\n  function mint(address _recipient, uint256 _amount) external;\n\n  function transferTokenOwnership(address _newOwner) external;\n\n  function addMinter(address _newMinter) external;\n\n  function revokeMinter(address _minter) external;\n}\n"
    },
    "contracts/interfaces/IFeeRecipient.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IFeeRecipient {\n  function baseRate() external view returns (uint256);\n\n  function getBorrowingFee(uint256 _amount) external view returns (uint256);\n\n  function calcDecayedBaseRate(uint256 _currentBaseRate) external view returns (uint256);\n\n  /**\n     @dev is called to make the FeeRecipient contract transfer the fees to itself. It will use transferFrom to get the\n     fees from the msg.sender\n     @param _amount the amount in Wei of fees to transfer\n     */\n  function takeFees(uint256 _amount) external returns (bool);\n\n  function increaseBaseRate(uint256 _increase) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILiquidationPool.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/constants.sol\";\n\ninterface ILiquidationPool {\n  function collateral() external view returns (uint256);\n\n  function debt() external view returns (uint256);\n\n  function liqTokenRate() external view returns (uint256);\n\n  function claimCollateralAndDebt(uint256 _unclaimedCollateral, uint256 _unclaimedDebt) external;\n\n  function approveTrove(address _trove) external;\n\n  function unapproveTrove(address _trove) external;\n\n  function liquidate() external;\n}\n"
    },
    "contracts/interfaces/IStabilityPoolBase.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/constants.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ITroveFactory.sol\";\nimport \"./IMintableToken.sol\";\n\ninterface IStabilityPoolBase {\n  function factory() external view returns (ITroveFactory);\n\n  function stableCoin() external view returns (IMintableToken);\n\n  function bonqToken() external view returns (IERC20);\n\n  function totalDeposit() external view returns (uint256);\n\n  function withdraw(uint256 _amount) external;\n\n  function deposit(uint256 _amount) external;\n\n  function redeemReward() external;\n\n  function liquidate() external;\n\n  function setBONQPerMinute(uint256 _bonqPerMinute) external;\n\n  function setBONQAmountForRewards() external;\n\n  function getDepositorBONQGain(address _depositor) external view returns (uint256);\n\n  function getWithdrawableDeposit(address staker) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ITrove.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IOwnable.sol\";\nimport \"./ITroveFactory.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControlEnumerable.sol\";\n\ninterface ITrove is IOwnable, IAccessControlEnumerable {\n  function factory() external view returns (ITroveFactory);\n\n  function token() external view returns (IERC20);\n\n  // solhint-disable-next-line func-name-mixedcase\n  function OWNER_ROLE() external view returns (bytes32);\n\n  function addOwner(address _newOwner) external;\n\n  function removeOwner(address _ownerToRemove) external;\n\n  // solhint-disable-next-line func-name-mixedcase\n  function TOKEN_PRECISION() external view returns (uint256);\n\n  function mcr() external view returns (uint256);\n\n  function collateralization() external view returns (uint256);\n\n  function collateralValue() external view returns (uint256);\n\n  function collateral() external view returns (uint256);\n\n  function recordedCollateral() external view returns (uint256);\n\n  function debt() external view returns (uint256);\n\n  function netDebt() external view returns (uint256);\n\n  function bonqStake() external view returns (uint256);\n\n  //  function rewardRatioSnapshot() external view returns (uint256);\n\n  function initialize(\n    //    address _factory,\n    address _token,\n    address _troveOwner\n  ) external;\n\n  function increaseCollateral(uint256 _amount, address _newNextTrove) external;\n\n  function decreaseCollateral(\n    address _recipient,\n    uint256 _amount,\n    address _newNextTrove\n  ) external;\n\n  function unstakeBONQ(uint256 _amount) external;\n\n  function borrow(\n    address _recipient,\n    uint256 _amount,\n    address _newNextTrove\n  ) external;\n\n  function repay(uint256 _amount, address _newNextTrove) external;\n\n  function redeem(address _recipient, address _newNextTrove)\n    external\n    returns (uint256 _stableAmount, uint256 _collateralRecieved);\n\n  function setArbitrageParticipation(bool _state) external;\n}\n"
    },
    "contracts/interfaces/IServiceFeeGenerator.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ITrove.sol\";\nimport \"./IFeeRecipient.sol\";\n\ninterface IServiceFeeGenerator {\n  function trove() external view returns (ITrove);\n\n  function feeRecipient() external view returns (IFeeRecipient);\n\n  function feeAmount() external view returns (uint256);\n\n  function feeInterval() external view returns (uint256);\n\n  function lastPayTime() external view returns (uint256);\n\n  function isPaid() external view returns (bool);\n\n  function initialized() external view returns (bool);\n\n  function initialize(\n    ITrove _trove,\n    uint256 _feeAmount,\n    uint256 _feeInterval\n  ) external;\n\n  /**\n     @dev is called to check if the interval passed and pay fee in that case\n     takes fees as debt from the trove set\n    */\n  function withdrawFee(address _newNextTrove) external;\n\n  event Activated(address indexed activator, address indexed trove, uint256 feeAmount, uint256 feeInterval);\n  event FeeCollected(uint256 indexed periodStart, uint256 indexed periodEnd);\n  event Deactivated(address indexed deactivator, uint256 indexed timestamp);\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/test/replacement-arbitrage-pool-uniswap.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../arbitrage-pool-uniswap.sol\";\n\ncontract ReplacementArbitragePoolUniswap is ArbitragePoolUniswap {\n  constructor(address _factory, address _router) ArbitragePoolUniswap(_factory, _router) {}\n\n  function name() public view override returns (string memory) {\n    return \"ReplacementArbitragePoolUniswap\";\n  }\n}\n"
    },
    "contracts/trove.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./interfaces/ITroveFactory.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IArbitragePool.sol\";\nimport \"./interfaces/IMintableToken.sol\";\nimport \"./utils/constants.sol\";\nimport \"./interfaces/IFeeRecipient.sol\";\nimport \"./utils/BONQMath.sol\";\n\ncontract Trove is ITrove, Ownable, Initializable, AccessControlEnumerable, Constants {\n  using BONQMath for uint256;\n  using SafeERC20 for IERC20;\n  using SafeERC20 for IERC20Metadata;\n\n  bytes32 public constant override OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n\n  struct ArbitrageState {\n    IArbitragePool arbitragePool;\n    IMintableToken apToken;\n    uint256 lastApPrice;\n  }\n\n  ITroveFactory public immutable override factory;\n  IERC20 public override token;\n  // solhint-disable-next-line var-name-mixedcase\n  uint256 public override TOKEN_PRECISION;\n\n  uint256 private _debt;\n  uint256 public liquidationReserve;\n  uint256 public override recordedCollateral;\n  uint256 public liqTokenRateSnapshot;\n  bool public arbitrageParticipation;\n  ArbitrageState public arbitrageState;\n  IERC20 public bonqToken;\n\n  event Liquidated(address trove, uint256 debt, uint256 collateral);\n\n  /**\n   * @dev restrict the call to be from the factory contract\n   */\n  modifier onlyFactory() {\n    require(msg.sender == address(factory), \"1210a only callable from factory\");\n    _;\n  }\n\n  modifier onlyTroveOwner() {\n    require(hasRole(OWNER_ROLE, msg.sender), \"cfa3b address is missing OWNER_ROLE\");\n    _;\n  }\n\n  modifier whenFactoryNotPaused() {\n    require(!Pausable(address(factory)).paused(), \"cfa4b Trove Factory is paused\");\n    _;\n  }\n\n  constructor(address _factory) {\n    factory = ITroveFactory(_factory);\n  }\n\n  function initialize(address _token, address _troveOwner) public override initializer {\n    //    require(_factory != address(0x0), \"41fe68 _factory must not be address 0x0\");\n    require(_token != address(0x0), \"41fe68 _token must not be address 0x0\");\n    require(_troveOwner != address(0x0), \"41fe68 _troveOwner must not be address 0x0\");\n    //    factory = ITroveFactory(_factory);\n    _transferOwnership(_troveOwner);\n    _initializeMainOwners(_troveOwner, address(factory));\n    token = IERC20(_token);\n    TOKEN_PRECISION = 10**(IERC20Metadata(_token).decimals());\n    liqTokenRateSnapshot = factory.liquidationPool(_token).liqTokenRate();\n    // allow the fee recipient contract to transfer as many tokens as it wants from the trove\n    factory.stableCoin().approve(address(factory.feeRecipient()), MAX_INT);\n    bonqToken = factory.bonqToken();\n  }\n\n  function owner() public view override(Ownable, IOwnable) returns (address) {\n    return Ownable.owner();\n  }\n\n  /**\n   * @dev the Minimum Collateralisation Ratio for this trove as set in the Token to Price Feed contract.\n   */\n  function mcr() public view override returns (uint256) {\n    return factory.tokenToPriceFeed().mcr(address(token));\n  }\n\n  /**\n   * @dev the reward in the liquidation pool which has not been claimed yet\n   */\n  function unclaimedArbitrageReward() public view returns (uint256) {\n    uint256 apBalance = arbitrageState.apToken.balanceOf(address(this));\n    uint256 newApPrice = arbitrageState.arbitragePool.getAPtokenPrice(address(token));\n    uint256 priceChange = newApPrice - arbitrageState.lastApPrice;\n    return (apBalance * priceChange) / DECIMAL_PRECISION;\n  }\n\n  /**\n   * @dev the reward in the liquidation pool which has not been claimed yet\n   */\n  function unclaimedCollateralRewardAndDebt() public view returns (uint256, uint256) {\n    ILiquidationPool pool = factory.liquidationPool(address(token));\n    uint256 currentLiqTokenRate = pool.liqTokenRate();\n    return _unclaimedCollateralRewardAndDebt(pool, currentLiqTokenRate);\n  }\n\n  /**\n   * @dev this function will return the actual collateral (balance of the collateral token) including any liquidation rewards from community liquidation\n   */\n  function collateral() public view override returns (uint256) {\n    (uint256 unclaimedCollateral, ) = unclaimedCollateralRewardAndDebt();\n    uint256 baseValue = token.balanceOf(address(this)) + unclaimedCollateral;\n    if (arbitrageParticipation) {\n      uint256 apBalance = arbitrageState.apToken.balanceOf(address(this));\n      uint256 newApPrice = arbitrageState.arbitragePool.getAPtokenPrice(address(token));\n      return baseValue + (apBalance * newApPrice) / DECIMAL_PRECISION;\n    }\n    return baseValue;\n  }\n\n  /**\n   * @dev this function will return the actual debt including any liquidation liabilities from community liquidation\n   */\n  function debt() public view override returns (uint256) {\n    (, uint256 unclaimedDebt) = unclaimedCollateralRewardAndDebt();\n    return _debt + unclaimedDebt;\n  }\n\n  /**\n   * @dev the net debt is the debt minus the liquidation reserve\n   */\n  function netDebt() public view override returns (uint256) {\n    return debt() - liquidationReserve;\n  }\n\n  function normalisedDecimals(uint256 tokenAmount) private view returns (uint256) {\n    return (tokenAmount * DECIMAL_PRECISION) / TOKEN_PRECISION;\n  }\n\n  /**\n   * @dev the value of the collateral * the current price as returned by the price feed contract for the collateral token\n   */\n  function collateralValue() public view override returns (uint256) {\n    return\n      (normalisedDecimals(collateral()) * factory.tokenToPriceFeed().tokenPrice(address(token))) / DECIMAL_PRECISION;\n  }\n\n  /**\n   * @dev the Individual Collateralisation Ratio (ICR) of the trove\n   */\n  function collateralization() public view override returns (uint256) {\n    uint256 troveDebt = debt();\n    if (troveDebt > 0) {\n      return (DECIMAL_PRECISION * collateralValue()) / troveDebt;\n    } else {\n      return MAX_INT;\n    }\n  }\n\n  /**\n   * @dev the Individual Collateralisation Ratio (ICR) of the trove. this private function can be used when it is certain\n   * that the _debt state variable has been updated correctly beforehand\n   */\n  function _collateralization() private view returns (uint256) {\n    if (_debt > 0) {\n      // the token price is multiplied by DECIMAL_PRECISION\n      return (normalisedDecimals(recordedCollateral) * factory.tokenToPriceFeed().tokenPrice(address(token))) / _debt;\n    } else {\n      return MAX_INT;\n    }\n  }\n\n  /**\n   * @dev transfers user's trove ownership after revoking other roles from other addresses\n   * @param _newOwner the address of the new owner\n   */\n  function transferOwnership(address _newOwner) public override(Ownable, IOwnable) {\n    Ownable.transferOwnership(_newOwner);\n    for (uint256 i = getRoleMemberCount(OWNER_ROLE); i > 0; i--) {\n      _revokeRole(OWNER_ROLE, getRoleMember(OWNER_ROLE, i - 1));\n    }\n    _initializeMainOwners(_newOwner, address(factory));\n  }\n\n  /**\n   * @dev add an address to the list of owners\n   * @param _newOwner the address of the new owner\n   */\n  function addOwner(address _newOwner) public override onlyTroveOwner {\n    _grantRole(OWNER_ROLE, _newOwner);\n  }\n\n  /**\n   * @dev add an address to the list of owners\n   * @param _ownerToRemove the address of the new owner\n   */\n  function removeOwner(address _ownerToRemove) public override onlyTroveOwner {\n    require(owner() != _ownerToRemove, \"604e3 do not remove main owner\");\n    _revokeRole(OWNER_ROLE, _ownerToRemove);\n  }\n\n  /**\n   * @dev used to set the OWNER_ROLE for _troveOwner and _factory\n   * @param _troveOwner the address of the new owner\n   * @param _factory the address of the factory\n   */\n  function _initializeMainOwners(address _troveOwner, address _factory) private {\n    _grantRole(OWNER_ROLE, _troveOwner);\n    _grantRole(OWNER_ROLE, _factory);\n  }\n\n  /**\n   * @dev insert the trove in the factory contract in the right spot of the list of troves with the same token\n   * @param _newNextTrove is the trove that we think will be the next one in the list. This might be off in case there were some other list changing transactions\n   */\n  function insertTrove(address _newNextTrove) private {\n    // insertTrove is only called after updateCollateral has been invoked and the _debt variable has been updated\n    require(_collateralization() >= mcr(), \"41670 TCR must be > MCR\");\n    // only call insertTrove if there are more than one troves in the list\n    address tokenAddress = address(token);\n    if (factory.troveCount(tokenAddress) > 1) {\n      factory.insertTrove(tokenAddress, _newNextTrove);\n    }\n  }\n\n  /**\n   * @dev mint some stable coins and pay the issuance fee. The transaction will fail if the resulting ICR < MCR\n   * @param _recipient is the address to which the newly minted tokens will be transferred\n   * @param _amount the value of the minting\n   * @param _newNextTrove is the trove that we think will be the next one in the list. This might be off in case there were some other list changing transactions\n   */\n  function borrow(\n    address _recipient,\n    uint256 _amount,\n    address _newNextTrove\n  ) public override onlyTroveOwner whenFactoryNotPaused {\n    uint256 feeAmount = _borrow(_amount, _newNextTrove);\n    IERC20(factory.stableCoin()).safeTransfer(_recipient, _amount);\n    // the event is emitted by the factory so that we don't need to spy on each trove to get the system status in PGSQL\n    factory.emitTroveDebtUpdate(address(token), _debt, _collateralization(), feeAmount);\n  }\n\n  /**\n   * @dev repay a portion of the debt by either sending some stable coins to the trove or allowing the trove to take tokens out of your balance\n   * @param _amount the amount of stable coins to reduce the debt with\n   * @param _newNextTrove is the trove that we think will be the next one in the list. This might be off in case there were some other list changing transactions\n   */\n  function repay(uint256 _amount, address _newNextTrove) public override {\n    // updates collateral and debt state variables hence there is no need to call the debt() function later\n    _updateCollateral();\n    require(_debt > 0, \"e37b2 debt must be gt than 0\");\n    IMintableToken stableCoin = factory.stableCoin();\n    uint256 liquidationReserve_cache = liquidationReserve;\n    if (_amount > 0) {\n      _amount = _amount.min(_debt - liquidationReserve_cache);\n      IERC20(stableCoin).safeTransferFrom(msg.sender, address(this), _amount);\n    } else {\n      _amount = _debt.min(stableCoin.balanceOf(address(this)) - liquidationReserve_cache);\n      require(_amount > 0, \"e37b2 insufficient funds\");\n    }\n\n    stableCoin.burn(_amount);\n    _debt -= _amount;\n    if (_debt == liquidationReserve_cache) {\n      stableCoin.burn(liquidationReserve_cache);\n      _amount += liquidationReserve_cache;\n      _debt = 0;\n      liquidationReserve = 0;\n    }\n    // reduce total debt (false == reduction)\n    factory.updateTotalDebt(_amount, false);\n    insertTrove(_newNextTrove);\n\n    factory.emitTroveDebtUpdate(address(token), _debt, _collateralization(), 0);\n  }\n\n  /**\n   * @dev if there have been liquidations since the last time this trove's state was updated, it should fetch the available rewards and debt\n   */\n  function getLiquidationRewards() internal {\n    IERC20 token_cache = token;\n    ILiquidationPool pool = factory.liquidationPool(address(token_cache));\n    uint256 currentLiqTokenRate = pool.liqTokenRate();\n    (uint256 unclaimedCollateral, uint256 unclaimedDebt) = _unclaimedCollateralRewardAndDebt(pool, currentLiqTokenRate);\n    if (unclaimedCollateral > 0) {\n      pool.claimCollateralAndDebt(unclaimedCollateral, unclaimedDebt);\n      recordedCollateral += unclaimedCollateral;\n      _debt += unclaimedDebt;\n      liqTokenRateSnapshot = currentLiqTokenRate;\n      if (arbitrageParticipation) {\n        arbitrageState.arbitragePool.deposit(address(token_cache), unclaimedCollateral);\n        arbitrageState.lastApPrice = arbitrageState.arbitragePool.getAPtokenPrice(address(token_cache));\n      }\n    }\n  }\n\n  /**\n   * @dev mint some stable coins and pay the issuance fee. The transaction will fail if the resulting ICR < MCR\n   * @param _amount the value of the minting\n   * @param _newNextTrove is the trove that we think will be the next one in the list. This might be off in case there were some other list changing transactions\n   * @param _feeAmount it's the minting fee\n   */\n  function _borrow(uint256 _amount, address _newNextTrove) private returns (uint256 _feeAmount) {\n    require(_amount >= DECIMAL_PRECISION, \"cb29c amount must be gt 1 token\");\n    _updateCollateral();\n    IFeeRecipient feeRecipient = factory.feeRecipient();\n    _feeAmount = feeRecipient.getBorrowingFee(_amount);\n    uint256 amountToMint = _amount + _feeAmount;\n\n    if (liquidationReserve == 0) {\n      liquidationReserve = LIQUIDATION_RESERVE;\n      amountToMint += LIQUIDATION_RESERVE;\n    }\n    _debt += amountToMint;\n    insertTrove(_newNextTrove);\n    factory.tokenOwner().mint(address(this), amountToMint);\n    feeRecipient.takeFees(_feeAmount);\n    // TODO: add debt to the parameters and call emitTroveDebtUpdate from updateTotalDebt to avoid two calls\n    factory.updateTotalDebt(amountToMint, true);\n  }\n\n  /**\n   * @dev the reward in the liquidation pool which has not been claimed yet\n   */\n  function _unclaimedCollateralRewardAndDebt(ILiquidationPool _pool, uint256 _currentLiqTokenRate)\n    private\n    view\n    returns (uint256, uint256)\n  {\n    uint256 _liqTokenRateSnapshot = liqTokenRateSnapshot;\n    // we use the recordedCollateral because the collateralPerStakedToken is computed with the explicitly added collateral only\n    uint256 unclaimedCollateral;\n    uint256 unclaimedDebt;\n\n    if (_currentLiqTokenRate > _liqTokenRateSnapshot) {\n      uint256 poolCollateral = _pool.collateral();\n      if (poolCollateral > 0) {\n        uint256 recordedCollateralCache = recordedCollateral;\n\n        unclaimedCollateral =\n          ((recordedCollateralCache * _currentLiqTokenRate) / _liqTokenRateSnapshot) -\n          recordedCollateralCache;\n        unclaimedDebt = (_pool.debt() * unclaimedCollateral) / _pool.collateral();\n      }\n    }\n    return (unclaimedCollateral, unclaimedDebt);\n  }\n\n  /**\n   * @dev update the state variables recordedCollateral and rewardRatioSnapshot and get all the collateral into the trove\n   */\n  function _updateCollateral() private returns (uint256) {\n    getLiquidationRewards();\n    uint256 startRecordedCollateral = recordedCollateral;\n    // make sure all tokens sent to or transferred out of the contract are taken into account\n    IERC20 token_cache = token;\n    uint256 newRecordedCollateral;\n    if (arbitrageParticipation) {\n      uint256 tokenBalance = token_cache.balanceOf(address(this));\n      if (tokenBalance > 0) arbitrageState.arbitragePool.deposit(address(token_cache), tokenBalance);\n      newRecordedCollateral = arbitrageState.apToken.balanceOf(address(this));\n      arbitrageState.lastApPrice = arbitrageState.arbitragePool.getAPtokenPrice(address(token_cache));\n    } else {\n      newRecordedCollateral = token_cache.balanceOf(address(this));\n    }\n    recordedCollateral = newRecordedCollateral;\n    // getLiquidationRewards updates recordedCollateral\n\n    if (newRecordedCollateral != startRecordedCollateral) {\n      factory.updateTotalCollateral(\n        address(token_cache),\n        newRecordedCollateral.max(startRecordedCollateral) - newRecordedCollateral.min(startRecordedCollateral),\n        newRecordedCollateral >= startRecordedCollateral\n      );\n    }\n    return newRecordedCollateral;\n  }\n\n  /**\n   * @dev there are two options to increase the collateral:\n   * 1. transfer the tokens to the trove and call increaseCollateral with amount = 0\n   * 2. grant the trove permission to transfer from your account and call increaseCollateral with amount > 0\n   * @param _amount a positive amount to transfer from the sender's account or zero\n   * @param _newNextTrove once the trove is better collateralised, its position in the list will change, the caller\n   * should indicate the new position in order to reduce gas consumption\n   */\n  function increaseCollateral(uint256 _amount, address _newNextTrove) public override {\n    IERC20 token_cache = token;\n    if (_amount > 0) {\n      token_cache.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n    uint256 newRecordedCollateral = _updateCollateral();\n\n    if (_debt > 0) {\n      insertTrove(_newNextTrove);\n    }\n    factory.emitTroveCollateralUpdate(address(token_cache), newRecordedCollateral, _collateralization());\n  }\n\n  /**\n   * @dev send some or all of the balance of the trove to an arbitrary address. Only the owner of the trove can do this\n   * as long as the debt is Zero, the transfer is performed without further checks.\n   * once the debt is not zero, the trove position in the trove list is changed to keep the list ordered by\n   * collateralisation ratio\n   * @param _recipient the address which will receive the tokens\n   * @param _amount amount of collateral\n   * @param _newNextTrove hint for next trove after reorder\n   */\n  function decreaseCollateral(\n    address _recipient,\n    uint256 _amount,\n    address _newNextTrove\n  ) public override onlyTroveOwner {\n    // make sure all the tokens are held by the trove before attempting to transfer\n    getLiquidationRewards();\n    IERC20 token_cache = token;\n    if (arbitrageParticipation) {\n      uint256 withdrawAmount = (_amount * TOKEN_PRECISION) /\n        arbitrageState.arbitragePool.getAPtokenPrice(address(token_cache));\n      arbitrageState.arbitragePool.withdraw(address(token_cache), withdrawAmount);\n    }\n    /* solhint-disable reentrancy */\n    // recordedCollateral is updated by calling _updateCollateral() before borrowing, repaying or increasing collateral.\n    // Calling this function in a reentrant way would not allow the attacker to get anything more\n    token_cache.safeTransfer(_recipient, _amount);\n    uint256 newRecordedCollateral = _updateCollateral();\n    /* solhint-disable reentrancy */\n\n    if (_debt > 0) {\n      // the ICR will be checked in insertTrove\n      insertTrove(_newNextTrove);\n    }\n    factory.emitTroveCollateralUpdate(address(token_cache), newRecordedCollateral, _collateralization());\n  }\n\n  /**\n   * @dev withdraw some BONQ from trove\n   * @param _amount amount of BONQ\n   */\n  function unstakeBONQ(uint256 _amount) public override onlyTroveOwner {\n    require(_amount <= bonqStake(), \"e6c7d7 withdraw amount exceeds balance\");\n    bonqToken.safeTransfer(msg.sender, _amount);\n  }\n\n  /**\n   * @dev get amount of BONQ staked in the trove\n   */\n  function bonqStake() public view override returns (uint256) {\n    return bonqToken.balanceOf(address(this));\n  }\n\n  /**\n   * @dev is called to redeem StableCoin for token, called by factory when MCR > ICR,\n   * amount of StableCoin is taken from balance and must be <= netDebt.\n   * uses priceFeed to calculate collateral amount.\n   * returns amount of StableCoin used and collateral received\n   * @param _recipient the address which receives redeemed token\n   * @param _newNextTrove hint for next trove after reorder, if it's not full redemption\n   */\n  function redeem(address _recipient, address _newNextTrove)\n    public\n    override\n    onlyFactory\n    returns (uint256 _stableAmount, uint256 _collateralReceived)\n  {\n    getLiquidationRewards();\n    require(mcr() <= _collateralization(), \"e957f TCR must be gte MCR\");\n    _stableAmount = factory.stableCoin().balanceOf(address(this)) - liquidationReserve;\n    require(\n      _newNextTrove == address(0) ? _stableAmount == netDebt() : _stableAmount <= netDebt(),\n      \"e957f amount != debt and no hint\"\n    );\n\n    IERC20 token_cache = token;\n\n    uint256 collateralToTransfer = (((_stableAmount * DECIMAL_PRECISION) /\n      factory.tokenToPriceFeed().tokenPrice(address(token_cache))) * TOKEN_PRECISION) / DECIMAL_PRECISION;\n\n    if (arbitrageParticipation) {\n      uint256 withdrawAmount = (collateralToTransfer * TOKEN_PRECISION) /\n        arbitrageState.arbitragePool.getAPtokenPrice(address(token_cache));\n      arbitrageState.arbitragePool.withdraw(address(token_cache), withdrawAmount);\n    }\n\n    token_cache.safeTransfer(_recipient, collateralToTransfer);\n    _collateralReceived = collateralToTransfer;\n\n    repay(0, _newNextTrove); // repays from trove balance transfered before call\n    return (_stableAmount, _collateralReceived);\n  }\n\n  /**\n   * @dev is called to liquidate the trove, if ICR < MCR then all the collateral is sent to the liquidation pool and the debt is forgiven\n   * the msg.sender is allowed to transfer the liquidation reserve out of the trove\n   */\n  function liquidate() public {\n    _updateCollateral();\n    require(_collateralization() < mcr(), \"454f4 CR must lt MCR\");\n    IERC20 token_cache = token;\n    IStabilityPoolBase stabilityPool = factory.stabilityPool();\n    // allow the sender to retrieve the liquidationReserve\n    factory.stableCoin().approve(msg.sender, liquidationReserve);\n    if (arbitrageParticipation) {\n      setArbitrageParticipation(false);\n    }\n    if (\n      !Pausable(address(factory)).paused() &&\n      (_collateralization() > DECIMAL_PRECISION) &&\n      (stabilityPool.totalDeposit() >= debt())\n    ) {\n      token_cache.safeApprove(address(stabilityPool), recordedCollateral);\n      // the collateral is transferred to the stabilityPool and is not used as collateral anymore\n      factory.updateTotalCollateral(address(token_cache), recordedCollateral, false);\n      factory.updateTotalDebt(_debt, false);\n      stabilityPool.liquidate();\n    } else {\n      ILiquidationPool pool = factory.liquidationPool(address(token_cache));\n      token_cache.safeApprove(address(pool), recordedCollateral);\n      pool.liquidate();\n      liqTokenRateSnapshot = pool.liqTokenRate();\n    }\n    _debt -= liquidationReserve;\n    emit Liquidated(address(this), _debt, recordedCollateral);\n    _debt = 0;\n    liquidationReserve = 0;\n    recordedCollateral = 0;\n    // liquidated troves have no debt and no collateral and should be removed from the list of troves\n    factory.removeTrove(address(token_cache), address(this));\n  }\n\n  /**\n   * @dev security function to make sure that if tokens are sent to the trove by mistake, they're not lost.\n   * It will always send the entire balance\n   * This function can not be used to transfer the collateral token\n   * @param _token the ERC20 to transfer\n   * @param _recipient the address the transfer should go to\n   */\n  function transferToken(address _token, address _recipient) public onlyTroveOwner {\n    require(_token != address(token), \"7a810 can't transfer collateral\");\n    require(_token != address(factory.stableCoin()), \"7a810 can't transfer stable coin\");\n    uint256 _amount = IERC20(_token).balanceOf(address(this));\n    IERC20(_token).safeTransfer(_recipient, _amount);\n  }\n\n  /**\n   * @dev configuration function to enable or disable collateral participation in ArbitragePool\n   * @param _state true/false to turn the state on/off\n   */\n  function setArbitrageParticipation(bool _state) public override onlyTroveOwner {\n    if (arbitrageParticipation == _state) return;\n    _updateCollateral();\n    IERC20 tokenCache = token;\n    arbitrageParticipation = _state;\n    IArbitragePool _arbitragePool = IArbitragePool(factory.arbitragePool());\n    if (_state) {\n      tokenCache.safeApprove(address(_arbitragePool), MAX_INT);\n      IMintableToken _apToken = _arbitragePool.collateralToAPToken(address(tokenCache));\n      _apToken.approve(address(_arbitragePool), MAX_INT);\n      arbitrageState.arbitragePool = _arbitragePool;\n      arbitrageState.apToken = _apToken;\n      uint256 tokenBalance = tokenCache.balanceOf(address(this));\n      if (tokenBalance > 0) _arbitragePool.deposit(address(tokenCache), tokenBalance);\n      arbitrageState.lastApPrice = _arbitragePool.getAPtokenPrice(address(tokenCache));\n    } else {\n      tokenCache.safeApprove(address(_arbitragePool), 0);\n      uint256 arbitrageBalance = arbitrageState.apToken.balanceOf(address(this));\n      if (arbitrageBalance > 0) arbitrageState.arbitragePool.withdraw(address(tokenCache), arbitrageBalance);\n      delete arbitrageState;\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "contracts/interfaces/IRouter.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IRouter {\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function getAmountOut(\n    uint256 amountIn,\n    address token0,\n    address token1\n  ) external view returns (uint256 amountOut);\n}\n"
    },
    "contracts/interfaces/IArbitragePool.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IOwnable.sol\";\nimport \"./IMintableToken.sol\";\n\ninterface IArbitragePool is IOwnable {\n  function collateralToAPToken(address) external returns (IMintableToken);\n\n  function getAPtokenPrice(address _collateralToken) external view returns (uint256);\n\n  function deposit(address _collateralToken, uint256 _amount) external;\n\n  function withdraw(address _collateralToken, uint256 _amount) external;\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/stability-pool-base.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n//import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./interfaces/IStabilityPoolBase.sol\";\nimport \"./interfaces/ITroveFactory.sol\";\nimport \"./interfaces/ITrove.sol\";\nimport \"./interfaces/IMintableToken.sol\";\nimport \"./utils/BONQMath.sol\";\nimport \"./interfaces/IRouter.sol\";\n\n/// @title is used to liquidate troves and reward depositors with collateral redeemed\ncontract StabilityPoolBase is\n  IStabilityPoolBase,\n  UUPSUpgradeable,\n  OwnableUpgradeable,\n  ReentrancyGuardUpgradeable,\n  Constants\n{\n  using BONQMath for uint256;\n  using SafeERC20 for IERC20;\n\n  struct TokenToS {\n    address tokenAddress;\n    uint256 S_value;\n  }\n\n  struct TokenToUint256 {\n    address tokenAddress;\n    uint256 value;\n  }\n\n  struct Snapshots {\n    TokenToS[] tokenToSArray;\n    uint256 P;\n    uint256 G;\n    uint128 scale;\n    uint128 epoch;\n  }\n\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  ITroveFactory public immutable override factory;\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  IMintableToken public immutable override stableCoin;\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  IERC20 public immutable override bonqToken;\n\n  uint256 public override totalDeposit;\n\n  mapping(address => uint256) public collateralToLastErrorOffset;\n  uint256 public lastStableCoinLossErrorOffset;\n\n  mapping(address => uint256) public deposits;\n  mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct\n\n  uint256 public bonqPerMinute;\n  uint256 public totalBONQRewardsLeft;\n  uint256 public latestBONQRewardTime;\n  // Error tracker for the error correction in the BONQ redistribution calculation\n  uint256 public lastBONQError;\n  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n   * after a series of liquidations have occurred, each of which cancel some StableCoin debt with the deposit.\n   *\n   * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n   * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n   */\n  uint256 public P;\n\n  uint256 public constant SCALE_FACTOR = 1e9;\n\n  uint256 public constant SECONDS_IN_ONE_MINUTE = 60;\n\n  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n  uint128 public currentScale;\n\n  // With each offset that fully empties the Pool, the epoch is incremented by 1\n  uint128 public currentEpoch;\n\n  /* Collateral Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral gain of ( d_t * [S - S_t] )/P_t, where S_t\n   * is the depositor's snapshot of S taken at the time t when the deposit was made.\n   *\n   * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n   *\n   * - The inner mapping records the sum S at different scales\n   * - The outer mapping records the (scale => sum) mappings, for different epochs.\n   */\n  mapping(uint128 => mapping(uint128 => TokenToS[])) public epochToScaleToTokenToSum;\n\n  /*\n   * Similarly, the sum 'G' is used to calculate BONQ gains. During it's lifetime, each deposit d_t earns a BONQ gain of\n   *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\n   *\n   *  BONQ reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n   *  In each case, the BONQ reward is issued (i.e. G is updated), before other state changes are made.\n   */\n  mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;\n\n  event Deposit(address _contributor, uint256 _amount);\n  event TotalDepositUpdated(uint256 _newValue);\n  event Withdraw(address _contributor, uint256 _amount);\n  event Arbitrage(address[] _path, uint256 _amountIn, uint256 _amountOut);\n\n  // solhint-disable-next-line event-name-camelcase\n  event BONQRewardRedeemed(address _contributor, uint256 _amount);\n  event BONQRewardIssue(uint256 issuance, uint256 _totalBONQRewardsLeft);\n  event BONQPerMinuteUpdated(uint256 _newAmount);\n  event TotalBONQRewardsUpdated(uint256 _newAmount);\n  // solhint-disable-next-line event-name-camelcase\n  event CollateralRewardRedeemed(\n    address _contributor,\n    address _tokenAddress,\n    uint256 _amount,\n    uint256 _collateralPrice\n  );\n  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G, uint256 _newDepositValue);\n\n  /* solhint-disable event-name-camelcase */\n  event P_Updated(uint256 _P);\n  event S_Updated(address _tokenAddress, uint256 _S, uint128 _epoch, uint128 _scale);\n  event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\n  /* solhint-disable event-name-camelcase */\n  event EpochUpdated(uint128 _currentEpoch);\n  event ScaleUpdated(uint128 _currentScale);\n\n  /// @custom:oz-upgrades-unsafe-allow constructor state-variable-immutable\n  constructor(address _factory, address _bonqToken) {\n    require(_factory != address(0x0), \"3f8955 trove factory must not be address 0x0\");\n    require(_bonqToken != address(0x0), \"3f8955 bonq token must not be address 0x0\");\n    factory = ITroveFactory(_factory);\n    stableCoin = IMintableToken(address(ITroveFactory(_factory).stableCoin()));\n    bonqToken = IERC20(_bonqToken);\n    // to prevent contract implementation to be reinitialized by someone else\n    _disableInitializers();\n  }\n\n  function initialize() public initializer {\n    __Ownable_init();\n    __ReentrancyGuard_init();\n    P = DECIMAL_PRECISION;\n  }\n\n  /// @dev make the contract upgradeable by its owner\n  function _authorizeUpgrade(address) internal override onlyOwner {}\n\n  /// @dev to deposit StableCoin into StabilityPool this must be protected against a reentrant attack from the arbitrage\n  /// @param  _amount amount to deposit\n  function deposit(uint256 _amount) public override nonReentrant {\n    // address depositor = msg.sender;\n    require(_amount > 0, \"d87c1 deposit amount must be bigger than zero\");\n\n    stableCoin.transferFrom(msg.sender, address(this), _amount);\n    uint256 initialDeposit = deposits[msg.sender];\n    _redeemReward();\n\n    Snapshots memory snapshots = depositSnapshots[msg.sender];\n\n    uint256 compoundedDeposit = _getCompoundedDepositFromSnapshots(initialDeposit, snapshots);\n    // uint256 newValue = compoundedDeposit + _amount;\n    uint256 newTotalDeposit = totalDeposit + _amount;\n    totalDeposit = newTotalDeposit;\n\n    _updateDepositAndSnapshots(msg.sender, compoundedDeposit + _amount);\n\n    emit Deposit(msg.sender, _amount);\n    emit TotalDepositUpdated(newTotalDeposit);\n  }\n\n  /// @dev to withdraw StableCoin that was not spent if this function is called in a reentrantway during arbitrage  it\n  /// @dev would skew the token allocation and must be protected against\n  /// @param  _amount amount to withdraw\n  function withdraw(uint256 _amount) public override nonReentrant {\n    uint256 contributorDeposit = deposits[msg.sender];\n    require(_amount > 0, \"f6c8a withdrawal amount must be bigger than 0\");\n    require(contributorDeposit > 0, \"f6c8a user has no deposit\");\n    _redeemReward();\n\n    Snapshots memory snapshots = depositSnapshots[msg.sender];\n\n    uint256 compoundedDeposit = _getCompoundedDepositFromSnapshots(contributorDeposit, snapshots);\n    uint256 calculatedAmount = compoundedDeposit.min(_amount);\n\n    uint256 newValue = compoundedDeposit - calculatedAmount;\n\n    totalDeposit = totalDeposit - calculatedAmount;\n\n    _updateDepositAndSnapshots(msg.sender, newValue);\n\n    stableCoin.transfer(msg.sender, calculatedAmount);\n    emit Withdraw(msg.sender, calculatedAmount);\n    emit TotalDepositUpdated(totalDeposit);\n  }\n\n  /// @dev to withdraw collateral rewards earned after liquidations\n  /// @dev this function does not provide an opportunity for a reentrancy attack\n  function redeemReward() public override {\n    Snapshots memory snapshots = depositSnapshots[msg.sender];\n    uint256 contributorDeposit = deposits[msg.sender];\n\n    uint256 compoundedDeposit = _getCompoundedDepositFromSnapshots(contributorDeposit, snapshots);\n    _redeemReward();\n    _updateDepositAndSnapshots(msg.sender, compoundedDeposit);\n  }\n\n  /// @dev liquidates trove, must be called from that trove\n  /// @dev this function does not provide an opportunity for a reentrancy attack even though it would make the arbitrage\n  /// @dev fail because of the lowering of the stablecoin balance\n  /// @notice must be called by the valid trove\n  function liquidate() public override {\n    ITrove trove = ITrove(msg.sender);\n    IERC20 collateralToken = IERC20(trove.token());\n    address collateralTokenAddress = address(collateralToken);\n    ITroveFactory factory_cached = factory;\n    require(\n      factory_cached.containsTrove(address(collateralToken), msg.sender),\n      \"StabilityPool:liquidate: must be called from a valid trove\"\n    );\n    uint256 troveDebt = trove.debt();\n    uint256 totalStableCoin = totalDeposit; // cached to save an SLOAD\n    uint256 troveCollateral = trove.collateral();\n\n    collateralToken.safeTransferFrom(address(trove), address(this), troveCollateral);\n    (uint256 collateralGainPerUnitStaked, uint256 stableCoinLossPerUnitStaked) = _computeRewardsPerUnitStaked(\n      collateralTokenAddress,\n      troveCollateral,\n      troveDebt,\n      totalStableCoin\n    );\n    _updateRewardSumAndProduct(collateralTokenAddress, collateralGainPerUnitStaked, stableCoinLossPerUnitStaked);\n    _triggerBONQdistribution();\n\n    stableCoin.burn(troveDebt);\n    uint256 newTotalDeposit = totalStableCoin - troveDebt;\n    totalDeposit = newTotalDeposit;\n    emit TotalDepositUpdated(newTotalDeposit);\n    factory_cached.emitLiquidationEvent(address(collateralToken), msg.sender, address(this), troveCollateral);\n  }\n\n  /// @dev gets current deposit of msg.sender\n  function getWithdrawableDeposit(address staker) public view override returns (uint256) {\n    uint256 initialDeposit = deposits[staker];\n    Snapshots memory snapshots = depositSnapshots[staker];\n    return _getCompoundedDepositFromSnapshots(initialDeposit, snapshots);\n  }\n\n  /// @dev gets collateral reward of msg.sender\n  /// @param _token collateral token address\n  function getCollateralReward(address _token, address _depositor) external view returns (uint256) {\n    Snapshots memory _snapshots = depositSnapshots[_depositor];\n    uint256 _initialDeposit = deposits[_depositor];\n\n    uint128 epochSnapshot = _snapshots.epoch;\n    uint128 scaleSnapshot = _snapshots.scale;\n\n    TokenToS[] memory tokensToSum_cached = epochToScaleToTokenToSum[epochSnapshot][scaleSnapshot];\n    uint256 tokenArrayLength = tokensToSum_cached.length;\n\n    TokenToS memory cachedS;\n    for (uint128 i = 0; i < tokenArrayLength; i++) {\n      TokenToS memory S = tokensToSum_cached[i];\n      if (S.tokenAddress == _token) {\n        cachedS = S;\n        break;\n      }\n    }\n    if (cachedS.tokenAddress == address(0)) return 0;\n    uint256 relatedSValue_snapshot;\n    for (uint128 i = 0; i < _snapshots.tokenToSArray.length; i++) {\n      TokenToS memory S_snapsot = _snapshots.tokenToSArray[i];\n      if (S_snapsot.tokenAddress == _token) {\n        relatedSValue_snapshot = S_snapsot.S_value;\n        break;\n      }\n    }\n    TokenToS[] memory nextTokensToSum_cached = epochToScaleToTokenToSum[epochSnapshot][scaleSnapshot + 1];\n    uint256 nextScaleS;\n    for (uint128 i = 0; i < nextTokensToSum_cached.length; i++) {\n      TokenToS memory nextScaleTokenToS = nextTokensToSum_cached[i];\n      if (nextScaleTokenToS.tokenAddress == _token) {\n        nextScaleS = nextScaleTokenToS.S_value;\n        break;\n      }\n    }\n\n    uint256 P_Snapshot = _snapshots.P;\n\n    uint256 collateralGain = _getCollateralGainFromSnapshots(\n      _initialDeposit,\n      cachedS.S_value,\n      nextScaleS,\n      relatedSValue_snapshot,\n      P_Snapshot\n    );\n\n    return collateralGain;\n  }\n\n  /// @dev gets BONQ reward of _depositor\n  /// @param _depositor user address\n  function getDepositorBONQGain(address _depositor) external view override returns (uint256) {\n    uint256 totalBONQRewardsLeft_cached = totalBONQRewardsLeft;\n    uint256 totalStableCoin = totalDeposit;\n    if (totalBONQRewardsLeft_cached == 0 || bonqPerMinute == 0 || totalStableCoin == 0) {\n      return 0;\n    }\n\n    uint256 _bonqIssuance = bonqPerMinute * ((block.timestamp - latestBONQRewardTime) / SECONDS_IN_ONE_MINUTE);\n    if (totalBONQRewardsLeft_cached < _bonqIssuance) {\n      _bonqIssuance = totalBONQRewardsLeft_cached;\n    }\n\n    uint256 bonqGain = (_bonqIssuance * DECIMAL_PRECISION + lastBONQError) / totalStableCoin;\n    uint256 marginalBONQGain = bonqGain * P;\n\n    return _getDepositorBONQGain(_depositor, marginalBONQGain);\n  }\n\n  /// @dev sets amount of BONQ per minute for rewards\n  function setBONQPerMinute(uint256 _bonqPerMinute) external override onlyOwner {\n    _triggerBONQdistribution();\n    bonqPerMinute = _bonqPerMinute;\n    emit BONQPerMinuteUpdated(bonqPerMinute);\n  }\n\n  /// @dev sets total amount of BONQ to be rewarded (pays per minute until reaches the amount rewarded)\n  function setBONQAmountForRewards() external override onlyOwner {\n    _triggerBONQdistribution();\n    totalBONQRewardsLeft = bonqToken.balanceOf(address(this));\n    emit TotalBONQRewardsUpdated(totalBONQRewardsLeft);\n  }\n\n  function _redeemReward() private {\n    _redeemCollateralReward();\n    _triggerBONQdistribution();\n    _redeemBONQReward();\n  }\n\n  function _redeemCollateralReward() internal {\n    address depositor = msg.sender;\n    TokenToUint256[] memory depositorCollateralGains = _getDepositorCollateralGains(depositor);\n    _sendCollateralRewardsToDepositor(depositorCollateralGains);\n  }\n\n  function _redeemBONQReward() internal {\n    address depositor = msg.sender;\n    uint256 depositorBONQGain = _getDepositorBONQGain(depositor, 0);\n    _sendBONQRewardsToDepositor(depositorBONQGain);\n    emit BONQRewardRedeemed(depositor, depositorBONQGain);\n  }\n\n  /// @dev updates user deposit snapshot data for new deposit value\n  function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) private {\n    deposits[_depositor] = _newValue;\n    if (_newValue == 0) {\n      delete depositSnapshots[_depositor];\n      emit DepositSnapshotUpdated(_depositor, 0, 0, 0);\n      return;\n    }\n    uint128 cachedEpoch = currentEpoch;\n    uint128 cachedScale = currentScale;\n    TokenToS[] storage cachedTokenToSArray = epochToScaleToTokenToSum[cachedEpoch][cachedScale]; // TODO: maybe remove and read twice?\n    uint256 cachedP = P;\n    uint256 cachedG = epochToScaleToG[cachedEpoch][cachedScale];\n\n    depositSnapshots[_depositor].tokenToSArray = cachedTokenToSArray; // TODO\n    depositSnapshots[_depositor].P = cachedP;\n    depositSnapshots[_depositor].G = cachedG;\n    depositSnapshots[_depositor].scale = cachedScale;\n    depositSnapshots[_depositor].epoch = cachedEpoch;\n    emit DepositSnapshotUpdated(_depositor, cachedP, cachedG, _newValue);\n  }\n\n  function _updateRewardSumAndProduct(\n    address _collateralTokenAddress,\n    uint256 _collateralGainPerUnitStaked,\n    uint256 _stableCoinLossPerUnitStaked\n  ) internal {\n    assert(_stableCoinLossPerUnitStaked <= DECIMAL_PRECISION);\n\n    uint128 currentScaleCached = currentScale;\n    uint128 currentEpochCached = currentEpoch;\n    uint256 currentS;\n    uint256 currentSIndex;\n    bool _found;\n    TokenToS[] memory currentTokenToSArray = epochToScaleToTokenToSum[currentEpochCached][currentScaleCached];\n    for (uint128 i = 0; i < currentTokenToSArray.length; i++) {\n      if (currentTokenToSArray[i].tokenAddress == _collateralTokenAddress) {\n        currentS = currentTokenToSArray[i].S_value;\n        currentSIndex = i;\n        _found = true;\n      }\n    }\n    /*\n     * Calculate the new S first, before we update P.\n     * The Collateral gain for any given depositor from a liquidation depends on the value of their deposit\n     * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n     *\n     * Since S corresponds to Collateral gain, and P to deposit loss, we update S first.\n     */\n    uint256 marginalCollateralGain = _collateralGainPerUnitStaked * P;\n    uint256 newS = currentS + marginalCollateralGain;\n    if (currentTokenToSArray.length == 0 || !_found) {\n      TokenToS memory tokenToS;\n      tokenToS.S_value = newS;\n      tokenToS.tokenAddress = _collateralTokenAddress;\n      epochToScaleToTokenToSum[currentEpochCached][currentScaleCached].push() = tokenToS;\n    } else {\n      epochToScaleToTokenToSum[currentEpochCached][currentScaleCached][currentSIndex].S_value = newS;\n    }\n    emit S_Updated(_collateralTokenAddress, newS, currentEpochCached, currentScaleCached);\n    _updateP(_stableCoinLossPerUnitStaked, true);\n  }\n\n  function _updateP(uint256 _stableCoinChangePerUnitStaked, bool loss) internal {\n    /*\n     * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool StableCoin in the liquidation.\n     * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - StableCoinLossPerUnitStaked)\n     */\n    uint256 newProductFactor;\n    if (loss) {\n      newProductFactor = uint256(DECIMAL_PRECISION - _stableCoinChangePerUnitStaked);\n    } else {\n      newProductFactor = uint256(DECIMAL_PRECISION + _stableCoinChangePerUnitStaked);\n    }\n    uint256 currentP = P;\n    uint256 newP;\n    // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n    if (newProductFactor == 0) {\n      currentEpoch += 1;\n      emit EpochUpdated(currentEpoch);\n      currentScale = 0;\n      emit ScaleUpdated(0);\n      newP = DECIMAL_PRECISION;\n\n      // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n    } else if ((currentP * newProductFactor) / DECIMAL_PRECISION < SCALE_FACTOR) {\n      newP = (currentP * newProductFactor * SCALE_FACTOR) / DECIMAL_PRECISION;\n      currentScale += 1;\n      emit ScaleUpdated(currentScale);\n    } else {\n      newP = (currentP * newProductFactor) / DECIMAL_PRECISION;\n    }\n\n    assert(newP > 0);\n    P = newP;\n\n    emit P_Updated(newP);\n  }\n\n  /// @dev updates G when new BONQ amount is issued\n  /// @param _bonqIssuance new BONQ issuance amount\n  function _updateG(uint256 _bonqIssuance) internal {\n    uint256 totalStableCoin = totalDeposit; // cached to save an SLOAD\n    /*\n     * When total deposits is 0, G is not updated. In this case, the BONQ issued can not be obtained by later\n     * depositors - it is missed out on, and remains in the balanceof the Stability Pool.\n     *\n     */\n    if (totalStableCoin == 0 || _bonqIssuance == 0) {\n      return;\n    }\n\n    uint256 bonqPerUnitStaked;\n    bonqPerUnitStaked = _computeBONQPerUnitStaked(_bonqIssuance, totalStableCoin);\n\n    uint256 marginalBONQGain = bonqPerUnitStaked * P;\n    uint128 currentEpoch_cached = currentEpoch;\n    uint128 currentScale_cached = currentScale;\n\n    uint256 newEpochToScaleToG = epochToScaleToG[currentEpoch_cached][currentScale_cached] + marginalBONQGain;\n    epochToScaleToG[currentEpoch_cached][currentScale_cached] = newEpochToScaleToG;\n\n    emit G_Updated(newEpochToScaleToG, currentEpoch_cached, currentScale_cached);\n  }\n\n  function _getDepositorCollateralGains(address _depositor) internal view returns (TokenToUint256[] memory) {\n    uint256 initialDeposit = deposits[_depositor];\n    if (initialDeposit == 0) {\n      TokenToUint256[] memory x;\n      return x;\n    }\n\n    Snapshots memory snapshots = depositSnapshots[_depositor];\n\n    TokenToUint256[] memory gainPerCollateralArray = _getCollateralGainsArrayFromSnapshots(initialDeposit, snapshots);\n    return gainPerCollateralArray;\n  }\n\n  function _getCollateralGainsArrayFromSnapshots(uint256 _initialDeposit, Snapshots memory _snapshots)\n    internal\n    view\n    returns (TokenToUint256[] memory)\n  {\n    /*\n     * Grab the sum 'S' from the epoch at which the stake was made. The Collateral gain may span up to one scale change.\n     * If it does, the second portion of the Collateral gain is scaled by 1e9.\n     * If the gain spans no scale change, the second portion will be 0.\n     */\n    uint128 epochSnapshot = _snapshots.epoch;\n    uint128 scaleSnapshot = _snapshots.scale;\n    TokenToS[] memory tokensToSum_cached = epochToScaleToTokenToSum[epochSnapshot][scaleSnapshot];\n    uint256 tokenArrayLength = tokensToSum_cached.length;\n    TokenToUint256[] memory CollateralGainsArray = new TokenToUint256[](tokenArrayLength);\n    for (uint128 i = 0; i < tokenArrayLength; i++) {\n      TokenToS memory S = tokensToSum_cached[i];\n      uint256 relatedS_snapshot;\n      for (uint128 j = 0; j < _snapshots.tokenToSArray.length; j++) {\n        TokenToS memory S_snapsot = _snapshots.tokenToSArray[j];\n        if (S_snapsot.tokenAddress == S.tokenAddress) {\n          relatedS_snapshot = S_snapsot.S_value;\n          break;\n        }\n      }\n      TokenToS[] memory nextTokensToSum_cached = epochToScaleToTokenToSum[epochSnapshot][scaleSnapshot + 1];\n      uint256 nextScaleS;\n      for (uint128 j = 0; j < nextTokensToSum_cached.length; j++) {\n        TokenToS memory nextScaleTokenToS = nextTokensToSum_cached[j];\n        if (nextScaleTokenToS.tokenAddress == S.tokenAddress) {\n          nextScaleS = nextScaleTokenToS.S_value;\n          break;\n        }\n      }\n      uint256 P_Snapshot = _snapshots.P;\n\n      CollateralGainsArray[i].value = _getCollateralGainFromSnapshots(\n        _initialDeposit,\n        S.S_value,\n        nextScaleS,\n        relatedS_snapshot,\n        P_Snapshot\n      );\n      CollateralGainsArray[i].tokenAddress = S.tokenAddress;\n    }\n\n    return CollateralGainsArray;\n  }\n\n  function _getCollateralGainFromSnapshots(\n    uint256 initialDeposit,\n    uint256 S,\n    uint256 nextScaleS,\n    uint256 S_Snapshot,\n    uint256 P_Snapshot\n  ) internal pure returns (uint256) {\n    uint256 firstPortion = S - S_Snapshot;\n    uint256 secondPortion = nextScaleS / SCALE_FACTOR;\n    uint256 collateralGain = (initialDeposit * (firstPortion + secondPortion)) / P_Snapshot / DECIMAL_PRECISION;\n\n    return collateralGain;\n  }\n\n  function _getDepositorBONQGain(address _depositor, uint256 _marginalBONQGain) internal view returns (uint256) {\n    uint256 initialDeposit = deposits[_depositor];\n    if (initialDeposit == 0) {\n      return 0;\n    }\n    Snapshots memory _snapshots = depositSnapshots[_depositor];\n    /*\n     * Grab the sum 'G' from the epoch at which the stake was made. The BONQ gain may span up to one scale change.\n     * If it does, the second portion of the BONQ gain is scaled by 1e9.\n     * If the gain spans no scale change, the second portion will be 0.\n     */\n    uint256 firstEpochPortion = epochToScaleToG[_snapshots.epoch][_snapshots.scale];\n    uint256 secondEpochPortion = epochToScaleToG[_snapshots.epoch][_snapshots.scale + 1];\n    if (_snapshots.epoch == currentEpoch) {\n      if (_snapshots.scale == currentScale) firstEpochPortion += _marginalBONQGain;\n      if (_snapshots.scale + 1 == currentScale) secondEpochPortion += _marginalBONQGain;\n    }\n    uint256 gainPortions = firstEpochPortion - _snapshots.G + secondEpochPortion / SCALE_FACTOR;\n\n    return (initialDeposit * (gainPortions)) / _snapshots.P / DECIMAL_PRECISION;\n  }\n\n  /// @dev gets compounded deposit of the user\n  function _getCompoundedDepositFromSnapshots(uint256 _initialStake, Snapshots memory _snapshots)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 snapshot_P = _snapshots.P;\n\n    // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n    if (_snapshots.epoch < currentEpoch) {\n      return 0;\n    }\n\n    uint256 compoundedStake;\n    uint128 scaleDiff = currentScale - _snapshots.scale;\n\n    /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n     * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n     * at least 1e-9 -- so return 0.\n     */\n    uint256 calculatedSnapshotP = snapshot_P == 0 ? DECIMAL_PRECISION : snapshot_P;\n    if (scaleDiff == 0) {\n      compoundedStake = (_initialStake * P) / calculatedSnapshotP;\n    } else if (scaleDiff == 1) {\n      compoundedStake = (_initialStake * P) / calculatedSnapshotP / SCALE_FACTOR;\n    } else {\n      // if scaleDiff >= 2\n      compoundedStake = 0;\n    }\n\n    /*\n     * If compounded deposit is less than a billionth of the initial deposit, return 0.\n     *\n     * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n     * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n     * than it's theoretical value.\n     *\n     * Thus it's unclear whether this line is still really needed.\n     */\n    if (compoundedStake < _initialStake / 1e9) {\n      return 0;\n    }\n\n    return compoundedStake;\n  }\n\n  /// @dev Compute the StableCoin and Collateral rewards. Uses a \"feedback\" error correction, to keep\n  /// the cumulative error in the P and S state variables low:s\n  function _computeRewardsPerUnitStaked(\n    address _collateralTokenAddress,\n    uint256 _collToAdd,\n    uint256 _debtToOffset,\n    uint256 _totalStableCoinDeposits\n  ) internal returns (uint256 collateralGainPerUnitStaked, uint256 stableCoinLossPerUnitStaked) {\n    /*\n     * Compute the StableCoin and Collateral rewards. Uses a \"feedback\" error correction, to keep\n     * the cumulative error in the P and S state variables low:\n     *\n     * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n     * function was called.\n     * 2) Calculate \"per-unit-staked\" ratios.\n     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n     * 4) Store these errors for use in the next correction when this function is called.\n     * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n     */\n    uint256 collateralNumerator = _collToAdd * DECIMAL_PRECISION + collateralToLastErrorOffset[_collateralTokenAddress];\n\n    assert(_debtToOffset <= _totalStableCoinDeposits);\n    if (_debtToOffset == _totalStableCoinDeposits) {\n      stableCoinLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n      lastStableCoinLossErrorOffset = 0;\n    } else {\n      uint256 stableCoinLossNumerator = _debtToOffset * DECIMAL_PRECISION - lastStableCoinLossErrorOffset;\n      /*\n       * Add 1 to make error in quotient positive. We want \"slightly too much\" StableCoin loss,\n       * which ensures the error in any given compoundedStableCoinDeposit favors the Stability Pool.\n       */\n      stableCoinLossPerUnitStaked = stableCoinLossNumerator / _totalStableCoinDeposits + 1;\n      lastStableCoinLossErrorOffset = stableCoinLossPerUnitStaked * _totalStableCoinDeposits - stableCoinLossNumerator;\n    }\n\n    collateralGainPerUnitStaked = collateralNumerator / _totalStableCoinDeposits;\n    collateralToLastErrorOffset[_collateralTokenAddress] =\n      collateralNumerator -\n      collateralGainPerUnitStaked *\n      _totalStableCoinDeposits;\n\n    return (collateralGainPerUnitStaked, stableCoinLossPerUnitStaked);\n  }\n\n  /// @dev distributes BONQ per minutes that was not spent yet\n  function _triggerBONQdistribution() internal {\n    uint256 issuance = _issueBONQRewards();\n    _updateG(issuance);\n  }\n\n  function _issueBONQRewards() internal returns (uint256) {\n    uint256 newBONQRewardTime = block.timestamp;\n    uint256 totalBONQRewardsLeft_cached = totalBONQRewardsLeft;\n    if (totalBONQRewardsLeft_cached == 0 || bonqPerMinute == 0 || totalDeposit == 0) {\n      latestBONQRewardTime = newBONQRewardTime;\n      return 0;\n    }\n\n    uint256 timePassedInMinutes = (newBONQRewardTime - latestBONQRewardTime) / SECONDS_IN_ONE_MINUTE;\n    uint256 issuance = bonqPerMinute * timePassedInMinutes;\n    if (totalBONQRewardsLeft_cached < issuance) {\n      issuance = totalBONQRewardsLeft_cached; // event will capture that 0 tokens left\n    }\n    uint256 newTotalBONQRewardsLeft = totalBONQRewardsLeft_cached - issuance;\n    totalBONQRewardsLeft = newTotalBONQRewardsLeft;\n    latestBONQRewardTime = newBONQRewardTime;\n\n    emit BONQRewardIssue(issuance, newTotalBONQRewardsLeft);\n\n    return issuance;\n  }\n\n  function _computeBONQPerUnitStaked(uint256 _bonqIssuance, uint256 _totalStableCoinDeposits)\n    internal\n    returns (uint256)\n  {\n    /*\n     * Calculate the BONQ-per-unit staked.  Division uses a \"feedback\" error correction, to keep the\n     * cumulative error low in the running total G:\n     *\n     * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n     * function was called.\n     * 2) Calculate \"per-unit-staked\" ratio.\n     * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n     * 4) Store this error for use in the next correction when this function is called.\n     * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n     */\n    uint256 bonqNumerator = _bonqIssuance * DECIMAL_PRECISION + lastBONQError;\n\n    uint256 bonqPerUnitStaked = bonqNumerator / _totalStableCoinDeposits;\n    lastBONQError = bonqNumerator - (bonqPerUnitStaked * _totalStableCoinDeposits);\n\n    return bonqPerUnitStaked;\n  }\n\n  /// @dev transfers collateral rewards tokens precalculated to the depositor\n  function _sendCollateralRewardsToDepositor(TokenToUint256[] memory _depositorCollateralGains) internal {\n    for (uint256 i = 0; i < _depositorCollateralGains.length; i++) {\n      if (_depositorCollateralGains[i].value == 0) {\n        continue;\n      }\n      IERC20 collateralToken = IERC20(_depositorCollateralGains[i].tokenAddress);\n      collateralToken.safeTransfer(msg.sender, _depositorCollateralGains[i].value);\n      uint256 collateralPrice = factory.tokenToPriceFeed().tokenPrice(address(collateralToken));\n      emit CollateralRewardRedeemed(\n        msg.sender,\n        _depositorCollateralGains[i].tokenAddress,\n        _depositorCollateralGains[i].value,\n        collateralPrice\n      );\n    }\n  }\n\n  /// @dev transfers BONQ amount to the user\n  function _sendBONQRewardsToDepositor(uint256 _bonqGain) internal {\n    bonqToken.transfer(msg.sender, _bonqGain);\n  }\n}\n"
    },
    "contracts/test/replacement-stability-pool.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"../stability-pool-base.sol\";\nimport \"../interfaces/uniswap/IUniswapV3Router.sol\";\n\ncontract ReplacementStabilityPool is StabilityPoolBase {\n  IUniswapV3Router public router;\n\n  event NewReplacementEvent(string); // this\n\n  constructor(address _factory, address _bonqToken) StabilityPoolBase(_factory, _bonqToken) {}\n\n  /// test that we can update method\n  function setRouterNew(address _router) public onlyOwner {\n    router = IUniswapV3Router(_router);\n    stableCoin.approve(_router, MAX_INT);\n    emit NewReplacementEvent(\"Replacement test\"); // this\n  }\n}\n"
    },
    "contracts/UniswapV3Arbitrage.sol": {
      "content": "import \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/uniswap/IUniswapV3Router.sol\";\n\nabstract contract UniswapV3Arbitrage is ReentrancyGuardUpgradeable {\n  /// @dev use the DEX router to trigger a swap that starts and ends with the stable coin and yields more coins than it\n  /// @dev requied as input. This function could be subject to a reentrant attack from a malicious token in the DEX\n  /// @param  _amountIn start amount\n  /// @param  _path calldata[]\n  /// @param  _fees calldata[] fees array in correct order\n  function _arbitrage(\n    IUniswapV3Router router,\n    uint256 _amountIn,\n    address[] calldata _path,\n    uint24[] calldata _fees,\n    uint256 _deadline\n  ) internal returns (uint256) {\n    require(_path[0] == _path[_path.length - 1], \"eafe9 must start and end with same coin\");\n    require(block.timestamp < _deadline || _deadline == 0, \"eafe9 too late\");\n\n    IERC20 token = IERC20(_path[0]);\n    // if the deadline was not set it is set to NOW - as the swap will happen in the same block it will be soon enough\n    uint256 startBalance = token.balanceOf(address(this));\n    // the swap must yield at least 1 coin (in ETH parlance: 1 Wei) more than what was put in and the TX has 10 minutes to execute\n    IUniswapV3Router.ExactInputParams memory swapParams = IUniswapV3Router.ExactInputParams(\n      _constructUniswapPath(_path, _fees),\n      address(this),\n      _amountIn,\n      _amountIn + 1\n    );\n    router.exactInput(swapParams);\n    uint256 amountOut = token.balanceOf(address(this)) - startBalance;\n    return amountOut;\n  }\n\n  /// @dev constructs uniswap swap path from arrays of tokens and pool fees\n  /// @param  _path address[] of tokens\n  /// @param  _fees uint24[] of pool fees\n  function _constructUniswapPath(address[] memory _path, uint24[] memory _fees)\n    private\n    pure\n    returns (bytes memory pathBytesString)\n  {\n    pathBytesString = abi.encodePacked(_path[0]);\n    for (uint256 i = 0; i < _fees.length; i++) {\n      pathBytesString = abi.encodePacked(pathBytesString, _fees[i], _path[i + 1]);\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/trove-factory.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\n//import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./interfaces/ITroveFactory.sol\";\nimport \"./interfaces/ITrove.sol\";\nimport \"./interfaces/IServiceFeeGenerator.sol\";\nimport \"./interfaces/IMintableTokenOwner.sol\";\nimport \"./interfaces/ITokenPriceFeed.sol\";\nimport \"./interfaces/IMintableToken.sol\";\nimport \"./interfaces/IFeeRecipient.sol\";\nimport \"./interfaces/IBONQStaking.sol\";\nimport \"./interfaces/ILiquidationPool.sol\";\nimport \"./interfaces/IStabilityPoolBase.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./utils/linked-address-list.sol\";\nimport \"./utils/BONQMath.sol\";\nimport \"./utils/constants.sol\";\n\nabstract contract TroveFactory is UUPSUpgradeable, OwnableUpgradeable, PausableUpgradeable, Constants, ITroveFactory {\n  using SafeERC20 for IERC20;\n  using LinkedAddressList for LinkedAddressList.List;\n  using BONQMath for uint256;\n\n  struct TroveList {\n    uint256 totalCollateral;\n    uint256 totalDebt;\n    ILiquidationPool liquidationPool;\n    LinkedAddressList.List list;\n  }\n\n  struct RedemptionInfo {\n    address collateralToken;\n    uint256 stableCoinRedeemed;\n    uint256 feeAmount;\n    uint256 collateralRedeemed;\n    uint256 stableCoinLeft;\n    address currentTroveAddress;\n    address lastTroveRedeemed;\n    ITrove currentRedemptionTrove;\n  }\n\n  // the trove lists must be separated by token because we want to keep the troves in order of collateralisation\n  // ratio and the token prices do not move in tandem\n  IStabilityPoolBase public override stabilityPool;\n  address public override arbitragePool;\n  mapping(address => TroveList) private _troves;\n  IMintableTokenOwner public override tokenOwner;\n  ITokenPriceFeed public override tokenToPriceFeed;\n  IMintableToken public override stableCoin;\n  // solhint-disable-next-line var-name-mixedcase\n  IWETH public WETHContract;\n  IFeeRecipient public override feeRecipient;\n  uint256 public override totalDebt;\n  address public troveImplementation;\n  address public serviceFeeImplementation;\n  /**\n   * @dev amount of staked BONQ at which trove has 100% refunding of redemption fee\n   */\n  uint256 public override maxTroveBONQStake;\n  IERC20 public override bonqToken;\n\n  event ServiceFeeImplementationSet(address previousImplementation, address newImplementation);\n  event NewServiceFee(address serviceFee, address subscriber, address trove);\n  event TroveImplementationSet(address previousImplementation, address newImplementation);\n  event NewTrove(address trove, address token, address owner);\n  event TroveRemoved(address trove);\n  event TroveLiquidated(\n    address trove,\n    address collateralToken,\n    uint256 priceAtLiquidation,\n    address stabilityPoolLiquidation,\n    uint256 collateral\n  );\n  event TroveInserted(address token, address trove, address referenceTrove, bool before);\n\n  event CollateralUpdate(address token, uint256 totalCollateral);\n  event DebtUpdate(address collateral, uint256 totalDebt);\n  event Redemption(\n    address token,\n    uint256 stableAmount,\n    uint256 tokenAmount,\n    uint256 stableUnspent,\n    uint256 startBaseRate,\n    uint256 finishBaseRate,\n    address lastTroveRedeemed\n  );\n  event TroveCollateralUpdate(address trove, address token, uint256 newAmount, uint256 newCollateralization);\n  event TroveDebtUpdate(\n    address trove,\n    address actor,\n    address token,\n    uint256 newAmount,\n    uint256 baseRate,\n    uint256 newCollateralization,\n    uint256 feePaid\n  );\n\n  constructor() {\n    // to prevent contract implementation to be reinitialized by someone else\n    _disableInitializers();\n  }\n\n  modifier troveExists(address _token, address _trove) {\n    require(containsTrove(_token, _trove), \"f9fac the trove has not been created by the factory\");\n    _;\n  }\n\n  // solhint-disable-next-line func-visibility\n  function initialize(address _stableCoin, address _feeRecipient) public initializer {\n    __Ownable_init();\n    __Pausable_init();\n    stableCoin = IMintableToken(_stableCoin);\n    feeRecipient = IFeeRecipient(_feeRecipient);\n    stableCoin.approve(address(feeRecipient), BONQMath.MAX_INT);\n  }\n\n  /// @dev make the contract upgradeable by its owner\n  function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n  function name() public view virtual returns (string memory);\n\n  /**\n   * @dev returns the number of troves for specific token\n   */\n  function troveCount(address _token) public view override returns (uint256) {\n    return _troves[_token].list._size;\n  }\n\n  /**\n   * @dev returns the last trove by maximum collaterization ratio\n   */\n  function lastTrove(address _token) public view override returns (address) {\n    return _troves[_token].list._last;\n  }\n\n  /**\n   * @dev returns the first trove by minimal collaterization ratio\n   */\n  function firstTrove(address _token) public view override returns (address) {\n    return _troves[_token].list._first;\n  }\n\n  /**\n   * @dev returns the next trove by collaterization ratio\n   */\n  function nextTrove(address _token, address _trove) public view override returns (address) {\n    return _troves[_token].list._values[_trove].next;\n  }\n\n  /**\n   * @dev returns the previous trove by collaterization ratio\n   */\n  function prevTrove(address _token, address _trove) public view override returns (address) {\n    return _troves[_token].list._values[_trove].prev;\n  }\n\n  /**\n   * @dev returns and checks if such trove exists for this token\n   */\n  function containsTrove(address _token, address _trove) public view override returns (bool) {\n    return _troves[_token].list._values[_trove].next != address(0x0);\n  }\n\n  /**\n   * @dev returns total collateral among all troves for specific token\n   */\n  function totalCollateral(address _token) public view override returns (uint256) {\n    return _troves[_token].totalCollateral;\n  }\n\n  /**\n   * @dev returns total debt among all troves for specific token\n   */\n  function totalDebtForToken(address _token) public view override returns (uint256) {\n    return _troves[_token].totalDebt;\n  }\n\n  /**\n   * @dev returns total collateral ratio averaged between troves for specific token\n   */\n  function tokenCollateralization(address _token) public view returns (uint256) {\n    return (_troves[_token].totalCollateral * DECIMAL_PRECISION) / _troves[_token].totalDebt;\n  }\n\n  /**\n   * @dev returns contract address of LiquidationPool for specific token\n   */\n  function liquidationPool(address _token) public view override returns (ILiquidationPool) {\n    return _troves[_token].liquidationPool;\n  }\n\n  /// @dev calculates redemption fee from CR\n  /// @param _collateralRatio collateral ratio of the trove\n  /// @param _mcr minimal collateral ratio of the trove\n  /// @return uint256 resulting fee\n  function _getRedemptionFeeRatio(uint256 _collateralRatio, uint256 _mcr) private pure returns (uint256) {\n    uint256 extraCR = (_collateralRatio - _mcr).min(_mcr * 15);\n    uint256 a = (((extraCR * extraCR) / _mcr) * DECIMAL_PRECISION) / _mcr;\n    uint256 b = _mcr * 45 - DECIMAL_PRECISION * 44;\n    uint256 tmpMin = (PERCENT10 * DECIMAL_PRECISION) / b;\n    uint256 minFee = tmpMin > PERCENT ? tmpMin - PERCENT_05 : PERCENT_05;\n\n    return (a * DECIMAL_PRECISION) / b + minFee;\n  }\n\n  /**\n   * @dev returns fee from redeeming the amount\n   */\n  function getRedemptionFeeRatio(address _trove) public view override returns (uint256) {\n    address collateral = address(ITrove(_trove).token());\n    ITokenPriceFeed ttpf = tokenToPriceFeed;\n    uint256 ratio = _getRedemptionFeeRatio(ITrove(_trove).collateralization(), ttpf.mcr(collateral));\n    return ratio.min(ttpf.mrf(collateral));\n  }\n\n  /**\n   * @dev returns fee from redeeming the amount\n   */\n  function getRedemptionFee(uint256 _feeRatio, uint256 _amount) public pure override returns (uint256) {\n    return (_amount * _feeRatio) / DECIMAL_PRECISION;\n  }\n\n  /**\n   * @dev returns reduced fee and amount to repay based on trove BONQ stake\n   */\n  function getReducedFeeAndRefundAmount(uint256 _fee, address _trove)\n    public\n    view\n    override\n    returns (uint256 _reducedFee, uint256 _refundAmount)\n  {\n    ITrove trove = ITrove(_trove);\n    uint256 _troveBonqStake = trove.bonqStake();\n    uint256 _maxTroveBONQStake_cached = maxTroveBONQStake;\n    if (_troveBonqStake == 0 || _maxTroveBONQStake_cached == 0) return (_fee, 0);\n    if (_troveBonqStake >= _maxTroveBONQStake_cached) return (0, _fee);\n    _refundAmount = (_fee * ((_troveBonqStake * DECIMAL_PRECISION) / _maxTroveBONQStake_cached)) / DECIMAL_PRECISION;\n    _reducedFee = _fee - _refundAmount;\n  }\n\n  /**\n   * @dev returns amount to be used in redemption excluding fee,\n   */\n  function getRedemptionAmount(uint256 _feeRatio, uint256 _amount) public pure returns (uint256) {\n    return (_amount * DECIMAL_PRECISION) / (DECIMAL_PRECISION + _feeRatio);\n  }\n\n  /**\n   * @dev returns fee from borrowing the amount\n   */\n  function getBorrowingFee(uint256 _amount) public view override returns (uint256) {\n    return feeRecipient.getBorrowingFee(_amount);\n  }\n\n  /**\n   * @dev sets address of the Trove implementation for minimal clones\n   */\n  function setTroveImplementation(address _troveImplementation) public onlyOwner {\n    emit TroveImplementationSet(troveImplementation, _troveImplementation);\n    troveImplementation = _troveImplementation;\n  }\n\n  /**\n   * @dev sets address of the contract for stableCoin issuance\n   */\n  function setTokenOwner() public onlyOwner {\n    IMintableToken stableCoin_cached = stableCoin;\n    tokenOwner = IMintableTokenOwner(address(stableCoin_cached.owner()));\n    require(tokenOwner.token() == stableCoin_cached, \"41642 the StableCoin must be owned by the token owner\");\n    require(tokenOwner.owner() == address(this), \"41642 this contract must be the owner of the token owner\");\n  }\n\n  /**\n   * @dev sets address of the service-fee-generator implementation for minimal clones\n   */\n  function setServiceFeeImplementation(address _serviceFeeImplementation) public onlyOwner {\n    emit ServiceFeeImplementationSet(serviceFeeImplementation, _serviceFeeImplementation);\n    serviceFeeImplementation = _serviceFeeImplementation;\n  }\n\n  /**\n   * @dev sets contract address of FeeRecipient\n   */\n  function setFeeRecipient(address _feeRecipient) public onlyOwner {\n    feeRecipient = IFeeRecipient(_feeRecipient);\n    stableCoin.approve(address(feeRecipient), BONQMath.MAX_INT);\n  }\n\n  /**\n   * @dev sets contract address of TokenPriceFeed\n   */\n  function setTokenPriceFeed(address _tokenPriceFeed) public onlyOwner {\n    tokenToPriceFeed = ITokenPriceFeed(_tokenPriceFeed);\n  }\n\n  /**\n   * @dev sets contract address of LiquidationPool for specific token\n   */\n  function setLiquidationPool(address _token, address _liquidationPool) public onlyOwner {\n    _troves[_token].liquidationPool = ILiquidationPool(_liquidationPool);\n  }\n\n  /**\n   * @dev sets contract address of StabilityPool\n   */\n  function setStabilityPool(address _stabilityPool) external override onlyOwner {\n    IStabilityPoolBase _stabilityPoolInstance = IStabilityPoolBase(_stabilityPool);\n    stabilityPool = _stabilityPoolInstance;\n    bonqToken = _stabilityPoolInstance.bonqToken();\n  }\n\n  /**\n   * @dev sets contract address of ArbitragePool\n   */\n  function setArbitragePool(address _arbitragePool) external override onlyOwner {\n    arbitragePool = _arbitragePool;\n  }\n\n  /**\n   * @dev sets contract address of Wrapped native token, along with liquidationPool\n   */\n  // solhint-disable-next-line var-name-mixedcase\n  function setWETH(address _WETH, address _liquidationPool) external override onlyOwner {\n    require(address(WETHContract) == address(0x0), \"cd9f3 WETH can only be set once\");\n    WETHContract = IWETH(_WETH);\n    setLiquidationPool(_WETH, _liquidationPool);\n  }\n\n  /**\n   * @dev sets new amount for trove BONQ state at which redemption fee refunding equals to 100%\n   */\n  // solhint-disable-next-line var-name-mixedcase\n  function setMaxTroveBONQStake(uint256 _newAmount) external override onlyOwner {\n    maxTroveBONQStake = _newAmount;\n  }\n\n  /**\n   * @dev transfers contract ownership\n   * this function is used when a new TroveFactory version is deployed and the same tokens are used. We transfer the\n   * ownership of the TokenOwner contract and the new TroveFactory is able to add minters\n   */\n  function transferTokenOwnership(address _newOwner) public onlyOwner {\n    tokenOwner.transferTokenOwnership(_newOwner);\n  }\n\n  /**\n   * @dev transfers contract ownership\n   * this function is used when a new TroveFactory version is deployed and the same tokens are used. We transfer the\n   * ownership of the TokenOwner contract and the new TroveFactory is able to add minters\n   */\n  function transferTokenOwnerOwnership(address _newOwner) public onlyOwner {\n    tokenOwner.transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev toggles the pause state of the contract\n   * if the contract is paused borrowing is disabled\n   * and liquidation with Stability Pool is impossible (Community liquidations still allowed)\n   */\n  function togglePause() public onlyOwner {\n    if (paused()) {\n      _unpause();\n    } else {\n      _pause();\n    }\n  }\n\n  /**\n   * @dev function to be called from trove to update total collateral value of all troves of this tokens\n   * @param _increase bool that indicates \"+\" or \"-\" operation\n   */\n  function updateTotalCollateral(\n    address _token,\n    uint256 _amount,\n    bool _increase\n  ) public override troveExists(_token, msg.sender) {\n    if (_increase) {\n      _troves[_token].totalCollateral += _amount;\n    } else {\n      _troves[_token].totalCollateral -= _amount;\n    }\n    emit CollateralUpdate(_token, _troves[_token].totalCollateral);\n  }\n\n  /**\n   * @dev deposits native token into trove after wrapping the ETH (EWT, AVAX, etc) into WETH (WEWT, WAVAX, etc)\n   * @param _trove tove to be deposited in\n   * @param _newNextTrove hint for next trove position\n   */\n  function increaseCollateralNative(address _trove, address _newNextTrove) public payable override {\n    ITrove targetTrove = ITrove(_trove);\n    IWETH WETHContract_cached = WETHContract;\n    require(address(targetTrove.token()) == address(WETHContract_cached), \"b8282 not a valid trove\");\n    WETHContract_cached.deposit{value: msg.value}();\n    require(WETHContract.transfer(_trove, msg.value), \"b8282 could not transfer the requested amount\");\n    targetTrove.increaseCollateral(0, _newNextTrove);\n  }\n\n  /**\n   * @dev creates a minimal clone from the implementation address\n   * @param _implementation any supported implementation\n   */\n  function cloneImplementation(address _implementation) internal returns (address clone) {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(ptr, 0x14), shl(0x60, _implementation))\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      clone := create(0, ptr, 0x37)\n    }\n  }\n\n  /**\n   * @dev creates new ServiceFeeGenerator for user\n   * @param _trove any valid trove that user owns\n   * @param _feeAmount amount of fee to take (must be >= minimal borrow)\n   * @param _feeInterval interval required for payments\n   */\n  function createNewServiceFee(\n    ITrove _trove,\n    uint256 _feeAmount,\n    uint256 _feeInterval\n  ) public override returns (IServiceFeeGenerator newServiceFee) {\n    // TODO add a mechanism to identify Service Fee contracts which were created by the trove Factory\n    require(containsTrove(address(_trove.token()), address(_trove)), \"daa708 not a valid trove\");\n    require(_trove.owner() == msg.sender, \"daa708 msg.sender must be trove owner\");\n\n    address serviceFeeAddress = cloneImplementation(serviceFeeImplementation);\n    require(serviceFeeAddress != address(0), \"ERC1167: create failed\");\n\n    _trove.addOwner(serviceFeeAddress);\n\n    newServiceFee = IServiceFeeGenerator(serviceFeeAddress);\n    newServiceFee.initialize(_trove, _feeAmount, _feeInterval);\n    emit NewServiceFee(serviceFeeAddress, msg.sender, address(_trove));\n  }\n\n  /**\n   * @dev creates a trove if the token is supported\n   * @param _token any supported token address\n   */\n  function createTrove(address _token) public override returns (ITrove trove) {\n    IMintableTokenOwner tokenOwner_cached = tokenOwner;\n    // troves can only be created after the token owner has been set. This is a safety check not security\n    require(address(tokenOwner_cached) != address(0x0), \"66c10 the token owner must be set\");\n    require(tokenOwner_cached.owner() == address(this), \"66c10 the token owner's owner must be the trove factory\");\n    // a token without a price feed has a CR of zero and is useless\n    require(tokenToPriceFeed.tokenPriceFeed(_token) != address(0x0), \"66c10 the token price feed must be set\");\n\n    address troveAddress = cloneImplementation(troveImplementation);\n    require(troveAddress != address(0), \"ERC1167: create failed\");\n\n    trove = ITrove(troveAddress);\n    //    trove.initialize(address(this), _token, msg.sender);\n    trove.initialize(_token, msg.sender);\n\n    require(_troves[_token].list.add(troveAddress, address(0x0), false), \"66c10 trove could not be added to the list\");\n    //allow the trove to transfer from the liquidation pool\n    _troves[_token].liquidationPool.approveTrove(troveAddress);\n    // allow the trove to mint stableCoin\n    tokenOwner_cached.addMinter(troveAddress);\n\n    emit NewTrove(troveAddress, _token, msg.sender);\n  }\n\n  /**\n   * @dev creates a trove with collateral and borrows from it\n   * @param _token any supported token address\n   * @param _collateralAmount a positive amount of collateral to transfer from the sender's account or zero\n   * @param _recipient is the address to which the newly minted tokens will be transferred\n   * @param _borrowAmount the value of the minting\n   * @param _nextTrove is the trove that we think will be the next one in the list. This might be off in case there were some other list changing transactions\n   */\n  function createTroveAndBorrow(\n    address _token,\n    uint256 _collateralAmount,\n    address _recipient,\n    uint256 _borrowAmount,\n    address _nextTrove\n  ) public override {\n    ITrove trove = createTrove(_token);\n    IERC20(_token).safeTransferFrom(msg.sender, address(trove), _collateralAmount);\n    trove.increaseCollateral(0, address(0));\n    if (_borrowAmount >= DECIMAL_PRECISION) trove.borrow(_recipient, _borrowAmount, _nextTrove);\n  }\n\n  /**\n   * @dev remove a trove from the list and send any remaining token balance to the owner\n   * @param _trove is the trove which will be removed\n   */\n  function removeTrove(address _token, address _trove) public override troveExists(_token, _trove) {\n    ITrove trove = ITrove(_trove);\n    require(\n      trove.owner() == msg.sender || _trove == msg.sender,\n      \"173fa only the owner can remove the trove from the list\"\n    );\n    require(trove.debt() == 0, \"173fa repay the debt before removing the trove\");\n    IERC20 token = IERC20(trove.token());\n    trove.setArbitrageParticipation(false);\n    uint256 tokenBalance = token.balanceOf(_trove);\n\n    if (tokenBalance > 0) {\n      // we can safely decrease the balance to zero with a newNextTrove of 0x0 because the debt is zero and\n      // insertTrove will not be called\n      // the collateral should be sent to the owner\n      // TODO: add test for this case\n      trove.decreaseCollateral(trove.owner(), tokenBalance, address(0x0));\n    }\n    require(_troves[_token].list.remove(_trove), \"173fa trove could not be removed from the list\");\n    tokenOwner.revokeMinter(_trove);\n    _troves[_token].liquidationPool.unapproveTrove(_trove);\n    emit TroveRemoved(_trove);\n  }\n\n  /**\n   * @dev insert a trove in the sorted list of troves. the troves must be sorted by collateralisation ratio CR\n   * the sender must be the trove which will be inserted in the list\n   * @param _newNextTrove is the trove before which the trove will be added\n   */\n  function insertTrove(address _token, address _newNextTrove) public override troveExists(_token, msg.sender) {\n    require(\n      containsTrove(_token, _newNextTrove) || _newNextTrove == address(0),\n      \"3a669 the trove hint must exist in the list or be 0x0\"\n    );\n\n    // if now hint is provided we start by trying the last trove in the list\n    if (_newNextTrove == address(0)) {\n      _newNextTrove = lastTrove(_token);\n    }\n\n    // if the NewNextTrove is the same as the trove being changed, then it should be changed to the trove's nextTrove\n    // unless the trove is the lastTrove in which case it is changed to the previousTrove\n    // insertTrove is never called if there is only one trove in the list\n    if (_newNextTrove == msg.sender) {\n      address nextTroveAddress = nextTrove(_token, _newNextTrove);\n      // the lastTrove has itself as the nextTrove\n      _newNextTrove = _newNextTrove != nextTroveAddress ? nextTroveAddress : prevTrove(_token, _newNextTrove);\n    }\n\n    ITrove trove = ITrove(msg.sender);\n    ITrove ref = ITrove(_newNextTrove);\n    bool insertBefore = true;\n\n    // first remove the trove from the list to avoid trying to insert it before or after itself\n    require(_troves[_token].list.remove(address(trove)), \"3a669 trove could not be removed from the list\");\n    if (trove.debt() == 0) {\n      // troves with zero debt have infinite collateralisation and can be put safely at the end of the list\n      require(\n        _troves[_token].list.add(address(trove), address(0x0), false),\n        \"3a669 trove could not be inserted in the list\"\n      );\n      emit TroveInserted(_token, address(trove), address(0x0), false);\n    } else {\n      uint256 icr = trove.collateralization();\n      uint256 refIcr = ref.collateralization();\n\n      if (refIcr >= icr) {\n        // if the first trove in the list has a bigger CR then this trove becomes the new first trove. No loop required\n        if (_newNextTrove != firstTrove(_token)) {\n          do {\n            // the previous trove of the new next trove should have a smaller or equal CR to the inserted trove\n            // it is cheaper (in gas) to assign the reference to the previous trove and insert after than to check twice for the CR\n            // this is why the loop is a \"do while\" instead of a \"while do\"\n            ref = ITrove(prevTrove(_token, address(ref)));\n            refIcr = ref.collateralization();\n          } while (refIcr > icr && address(ref) != _troves[_token].list._first);\n        }\n      }\n      // the ICR of the newNextTrove is smaller than the inserted trove's\n      else {\n        // only loop through the troves if the newNextTrove is not the last\n        if (_newNextTrove != lastTrove(_token)) {\n          do {\n            // the previous trove of the new next trove should have a smaller or equal CR to the inserted trove\n            ref = ITrove(nextTrove(_token, address(ref)));\n            refIcr = ref.collateralization();\n          } while (refIcr < icr && address(ref) != _troves[_token].list._last);\n        }\n      }\n\n      insertBefore = refIcr > icr;\n\n      require(\n        _troves[_token].list.add(address(trove), address(ref), insertBefore),\n        \"3a669 trove could not be inserted in the list\"\n      );\n      emit TroveInserted(_token, address(trove), address(ref), insertBefore);\n    }\n  }\n\n  /**\n   * @dev redeem all collateral the trove can provide\n   * @param _recipient is the trove _recipient to redeem colateral to and take stableCoin from\n   */\n  function _redeemFullTrove(address _recipient, address _trove)\n    internal\n    returns (uint256 _stableAmount, uint256 _collateralRecieved)\n  {\n    return _redeemPartTrove(_recipient, _trove, ITrove(_trove).netDebt(), address(0));\n  }\n\n  /**\n    @dev redeem collateral from the tove to fit desired stableCoin amount\n    @param _recipient is the trove _recipient to redeem colateral to and take stableCoin from\n    @param _stableAmount the desired amount of StableCoin to pay for redemption\n    @param _newNextTrove hint for the of the nextNewTrove after redemption\n    */\n  function _redeemPartTrove(\n    address _recipient,\n    address _trove,\n    uint256 _stableAmount,\n    address _newNextTrove\n  ) internal returns (uint256 stableAmount, uint256 collateralRecieved) {\n    ITrove trove = ITrove(_trove);\n    stableCoin.transferFrom(_recipient, _trove, _stableAmount);\n    return trove.redeem(_recipient, _newNextTrove);\n  }\n\n  /**\n   * @dev commits full redemptions until troves liquidity is less\n   */\n  function commitFullRedemptions(RedemptionInfo memory _redInfo, uint256 _maxRate)\n    internal\n    returns (RedemptionInfo memory)\n  {\n    ITrove currentRedemptionTrove = ITrove(_redInfo.currentTroveAddress);\n    uint256 currentFeeRatio = getRedemptionFeeRatio(_redInfo.currentTroveAddress) + feeRecipient.baseRate();\n    uint256 amountStableLeft = getRedemptionAmount(currentFeeRatio, _redInfo.stableCoinLeft);\n    while (\n      0 < currentRedemptionTrove.netDebt() &&\n      currentRedemptionTrove.netDebt() <= amountStableLeft &&\n      currentFeeRatio < _maxRate\n    ) {\n      _redInfo = commitFullRedeem(_redInfo, currentFeeRatio);\n      currentFeeRatio = getRedemptionFeeRatio(_redInfo.currentTroveAddress);\n      amountStableLeft = getRedemptionAmount(currentFeeRatio, _redInfo.stableCoinLeft);\n      currentRedemptionTrove = ITrove(_redInfo.currentTroveAddress);\n    }\n    return _redInfo;\n  }\n\n  /**\n   * @dev commits full redemption for the current trove, should be called after checks\n   */\n  function commitFullRedeem(RedemptionInfo memory _redInfo, uint256 _currentFeeRatio)\n    internal\n    returns (RedemptionInfo memory)\n  {\n    address nextTroveAddress = nextTrove(_redInfo.collateralToken, _redInfo.currentTroveAddress);\n    (uint256 stblRed, uint256 colRed) = _redeemFullTrove(msg.sender, _redInfo.currentTroveAddress);\n\n    _redInfo.stableCoinRedeemed += stblRed;\n    uint256 newFee = getRedemptionFee(_currentFeeRatio, stblRed);\n    (uint256 reducedFee, uint256 refundAmount) = getReducedFeeAndRefundAmount(newFee, _redInfo.currentTroveAddress);\n    _redInfo.feeAmount += reducedFee;\n    _redInfo.stableCoinLeft -= stblRed + reducedFee;\n    _redInfo.collateralRedeemed += colRed;\n    _redInfo.lastTroveRedeemed = _redInfo.currentTroveAddress;\n    _redInfo.currentTroveAddress = nextTroveAddress;\n\n    _refundFeeToTrove(_redInfo.currentTroveAddress, refundAmount);\n    return _redInfo;\n  }\n\n  /**\n   * @dev check if the Trove guessed ICR matches and commits partial redemptios\n   */\n  function commitPartRedeem(\n    RedemptionInfo memory _redInfo,\n    uint256 _maxRate,\n    uint256 _lastTroveCurrentICR,\n    address _lastTroveNewPositionHint\n  ) internal returns (RedemptionInfo memory) {\n    ITrove currentRedemptionTrove = ITrove(_redInfo.currentTroveAddress);\n    uint256 currentFeeRatio = getRedemptionFeeRatio(_redInfo.currentTroveAddress) + feeRecipient.baseRate();\n    if (currentRedemptionTrove.collateralization() == _lastTroveCurrentICR && currentFeeRatio < _maxRate) {\n      uint256 maxLastRedeem = BONQMath.min(\n        getRedemptionAmount(currentFeeRatio, _redInfo.stableCoinLeft),\n        currentRedemptionTrove.netDebt()\n      );\n      (uint256 stblRed, uint256 colRed) = _redeemPartTrove(\n        msg.sender,\n        _redInfo.currentTroveAddress,\n        maxLastRedeem,\n        _lastTroveNewPositionHint\n      );\n      _redInfo.stableCoinRedeemed += stblRed;\n      uint256 newFee = getRedemptionFee(currentFeeRatio, stblRed);\n      (uint256 reducedFee, uint256 refundAmount) = getReducedFeeAndRefundAmount(newFee, _redInfo.currentTroveAddress);\n      _redInfo.feeAmount += reducedFee;\n      _redInfo.stableCoinLeft -= stblRed + reducedFee;\n      _redInfo.collateralRedeemed += colRed;\n      _redInfo.lastTroveRedeemed = _redInfo.currentTroveAddress;\n\n      _refundFeeToTrove(_redInfo.currentTroveAddress, refundAmount);\n    }\n    return _redInfo;\n  }\n\n  /**\n   * @dev redeem desired StableCoin amount for desired collateral tokens\n   * @param _stableAmount the desired amount of StableCoin to pay for redemption\n   * @param _maxRate is max fee (in % with 1e18 precision) allowed to pay\n   * @param _lastTroveCurrentICR ICR of the last trove to be redeemed, if matches then the hint is working and it redeems\n   * @param _lastTroveNewPositionHint hint for the of the nextNewTrove after redemption for the latest trove\n   */\n  function redeemStableCoinForCollateral(\n    address _collateralToken,\n    uint256 _stableAmount,\n    uint256 _maxRate,\n    uint256 _lastTroveCurrentICR,\n    address _lastTroveNewPositionHint\n  ) public {\n    IMintableToken stableCoin_cached = stableCoin;\n    require(\n      ITrove(firstTrove(_collateralToken)).collateralization() > DECIMAL_PRECISION,\n      \"a7f99 first trove is undercollateralised and must be liquidated\"\n    );\n    require(stableCoin_cached.balanceOf(msg.sender) >= _stableAmount, \"a7f99 insufficient Fiat balance\");\n    require(\n      stableCoin_cached.allowance(msg.sender, address(this)) >= _stableAmount,\n      \"a7f99 StableCoin is not approved for factory\"\n    );\n\n    IFeeRecipient feeRecipient_cache = feeRecipient;\n    RedemptionInfo memory redInfo;\n    redInfo.collateralToken = _collateralToken;\n    redInfo.stableCoinLeft = _stableAmount;\n\n    redInfo.currentTroveAddress = firstTrove(_collateralToken);\n    redInfo = commitFullRedemptions(redInfo, _maxRate);\n    redInfo = commitPartRedeem(redInfo, _maxRate, _lastTroveCurrentICR, _lastTroveNewPositionHint);\n    if (redInfo.collateralRedeemed > 0) {\n      stableCoin_cached.transferFrom(msg.sender, address(this), redInfo.feeAmount);\n      feeRecipient_cache.takeFees(redInfo.feeAmount);\n\n      // TODO: increase base rate after each trove redemption\n      uint256 startBaseRate = feeRecipient_cache.baseRate();\n      uint256 finishBaseRate = feeRecipient_cache.increaseBaseRate(\n        (redInfo.stableCoinRedeemed * DECIMAL_PRECISION) / stableCoin_cached.totalSupply()\n      );\n      emit Redemption(\n        _collateralToken,\n        redInfo.stableCoinRedeemed,\n        redInfo.collateralRedeemed,\n        redInfo.stableCoinLeft,\n        startBaseRate,\n        finishBaseRate,\n        redInfo.lastTroveRedeemed\n      );\n    }\n  }\n\n  function _refundFeeToTrove(address _troveAddress, uint256 _refundAmount) private {\n    if (_refundAmount > 0) {\n      stableCoin.transferFrom(msg.sender, _troveAddress, _refundAmount);\n      ITrove(_troveAddress).repay(0, _troveAddress);\n    }\n  }\n\n  /**\n   * @dev function to be called from trove to change totalDebt\n   * @param _borrow indicates if it is borrow or repay/liquidatin\n   */\n  function updateTotalDebt(uint256 _amount, bool _borrow) public override {\n    ITrove trove = ITrove(msg.sender);\n    address token = address(trove.token());\n    require(containsTrove(token, msg.sender), \"fbfd5 not a valid trove\");\n    if (_borrow) {\n      totalDebt += _amount;\n      _troves[token].totalDebt += _amount;\n    } else {\n      totalDebt -= _amount;\n      _troves[token].totalDebt -= _amount;\n    }\n    emit DebtUpdate(token, totalDebt);\n  }\n\n  /// @dev to emit Liquidation event, to be called from a trove after liquidation.\n  /// @param  _token address of token\n  /// @param  _trove address of the Trove\n  /// @param  stabilityPoolLiquidation address of StabilityPool, 0x0 if Community LiquidationPool\n  /// @param  collateral uint256 amount of collateral\n  function emitLiquidationEvent(\n    address _token,\n    address _trove,\n    address stabilityPoolLiquidation,\n    uint256 collateral\n  ) public override {\n    emit TroveLiquidated(_trove, _token, tokenToPriceFeed.tokenPrice(_token), stabilityPoolLiquidation, collateral);\n  }\n\n  /// @dev to emit Trove's debt update event, to be called from trove\n  /// @param  _token address of token\n  /// @param  _newAmount new trove's debt value\n  /// @param  _newCollateralization new trove's collateralization value\n  function emitTroveDebtUpdate(\n    address _token,\n    uint256 _newAmount,\n    uint256 _newCollateralization,\n    uint256 _feePaid\n  ) external override {\n    emit TroveDebtUpdate(\n      address(msg.sender), // solhint-disable-next-line avoid-tx-origin\n      address(tx.origin),\n      _token,\n      _newAmount,\n      feeRecipient.baseRate(),\n      _newCollateralization,\n      _feePaid\n    );\n  }\n\n  /// @dev to emit Collateral update event, to be called from trove\n  /// @param  _token address of token\n  /// @param  _newAmount new trove's Collateral value\n  /// @param  _newCollateralization new trove's collateralization value\n  function emitTroveCollateralUpdate(\n    address _token,\n    uint256 _newAmount,\n    uint256 _newCollateralization\n  ) external override {\n    emit TroveCollateralUpdate(address(msg.sender), _token, _newAmount, _newCollateralization);\n  }\n}\n"
    },
    "contracts/interfaces/IBONQStaking.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/constants.sol\";\n\ninterface IBONQStaking {\n  /* view */\n  function totalStake() external view returns (uint256);\n\n  function getRewardsTotal() external view returns (uint256);\n\n  function getUnpaidStableCoinGain(address _user) external view returns (uint256);\n\n  /* state changes*/\n  function stake(uint256 _amount) external;\n\n  function unstake(uint256 _amount) external;\n\n  function redeemReward(\n    uint256 _amount,\n    address _troveAddress,\n    address _newNextTrove\n  ) external;\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IWETH {\n  function deposit() external payable;\n\n  function approve(address, uint256) external returns (bool);\n\n  function transfer(address _to, uint256 _value) external returns (bool);\n\n  function withdraw(uint256) external;\n}\n"
    },
    "contracts/utils/linked-address-list.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\n//import \"hardhat/console.sol\";\n\n/// @title implements LinkedList structure used to store/operate sorted Troves\nlibrary LinkedAddressList {\n  struct EntryLink {\n    address prev;\n    address next;\n  }\n\n  struct List {\n    address _last;\n    address _first;\n    uint256 _size;\n    mapping(address => EntryLink) _values;\n  }\n\n  function add(\n    List storage _list,\n    address _element,\n    address _reference,\n    bool _before\n  ) internal returns (bool) {\n    require(\n      _reference == address(0x0) || _list._values[_reference].next != address(0x0),\n      \"79d3d _ref neither valid nor 0x\"\n    );\n    // the lement must not exist in order to be added\n    EntryLink storage element_values = _list._values[_element];\n    if (element_values.prev == address(0x0)) {\n      // the list is empty\n      if (_list._last == address(0x0)) {\n        // if it is the first element in the list, it refers to itself to indicate this\n        element_values.prev = _element;\n        element_values.next = _element;\n        // the new element is now officially the first\n        _list._first = _element;\n        // the new element is now officially the last\n        _list._last = _element;\n      } else {\n        if (_before && (_reference == address(0x0) || _reference == _list._first)) {\n          // the element should be added as the first element\n          address first = _list._first;\n          _list._values[first].prev = _element;\n          element_values.prev = _element;\n          element_values.next = first;\n          _list._first = _element;\n        } else if (!_before && (_reference == address(0x0) || _reference == _list._last)) {\n          // the element should be added as the last element\n          address last = _list._last;\n          _list._values[last].next = _element;\n          element_values.prev = last;\n          element_values.next = _element;\n          _list._last = _element;\n        } else {\n          // the element should be inserted in between two elements\n          EntryLink memory ref = _list._values[_reference];\n          if (_before) {\n            element_values.prev = ref.prev;\n            element_values.next = _reference;\n            _list._values[_reference].prev = _element;\n            _list._values[ref.prev].next = _element;\n          } else {\n            element_values.prev = _reference;\n            element_values.next = ref.next;\n            _list._values[_reference].next = _element;\n            _list._values[ref.next].prev = _element;\n          }\n        }\n      }\n      _list._size = _list._size + 1;\n      return true;\n    }\n    return false;\n  }\n\n  function remove(List storage _list, address _element) internal returns (bool) {\n    EntryLink memory element_values = _list._values[_element];\n    if (element_values.next != address(0x0)) {\n      if (_element == _list._last && _element == _list._first) {\n        // it is the last element in the list\n        delete _list._last;\n        delete _list._first;\n      } else if (_element == _list._first) {\n        // simplified process for removing the first element\n        address next = element_values.next;\n        _list._values[next].prev = next;\n        _list._first = next;\n      } else if (_element == _list._last) {\n        // simplified process for removing the last element\n        address new_list_last = element_values.prev;\n        _list._last = new_list_last;\n        _list._values[new_list_last].next = new_list_last;\n      } else {\n        // set the previous and next to point to each other\n        address next = element_values.next;\n        address prev = element_values.prev;\n        _list._values[next].prev = prev;\n        _list._values[prev].next = next;\n      }\n      // in any case, delete the element itself\n      delete _list._values[_element];\n      _list._size = _list._size - 1;\n      return true;\n    }\n    return false;\n  }\n}\n"
    },
    "contracts/test/replacement-trove-factory.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"../trove-factory.sol\";\n\ncontract ReplacementTroveFactory is TroveFactory {\n  function name() public view override returns (string memory) {\n    return \"Replacement Factory\";\n  }\n}\n"
    },
    "contracts/test/test-address-list.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"../utils/linked-address-list.sol\";\n\ncontract TestAddressList {\n  using LinkedAddressList for LinkedAddressList.List;\n\n  LinkedAddressList.List private _addressList;\n\n  function addressListElement(address _element) public view returns (LinkedAddressList.EntryLink memory) {\n    return _addressList._values[_element];\n  }\n\n  function lastAddressListElement() public view returns (address) {\n    return _addressList._last;\n  }\n\n  function firstAddressListElement() public view returns (address) {\n    return _addressList._first;\n  }\n\n  function addressListSize() public view returns (uint256) {\n    return _addressList._size;\n  }\n\n  function appendAddress(address newAddress) public {\n    require(_addressList.add(newAddress, address(0x0), false), \"adding the list element failed\");\n  }\n\n  function addAddress(\n    address newAddress,\n    address _reference,\n    bool before\n  ) public {\n    require(_addressList.add(newAddress, _reference, before), \"adding the list element failed\");\n  }\n\n  function removeAddress(address _existingElement) public {\n    require(_addressList.remove(_existingElement), \"removing the list element failed\");\n  }\n}\n"
    },
    "contracts/interfaces/IStabilityPoolUniswap.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IStabilityPoolBase.sol\";\n\ninterface IStabilityPoolUniswap is IStabilityPoolBase {\n  function arbitrage(\n    uint256 _amountIn,\n    address[] calldata _path,\n    uint24[] calldata _fees,\n    uint256 expiry\n  ) external returns (uint256);\n\n  function setRouter(address _router) external;\n}\n"
    },
    "contracts/stability-pool-uniswap.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n//import \"hardhat/console.sol\";\nimport \"./interfaces/IStabilityPoolUniswap.sol\";\nimport \"./interfaces/uniswap/IUniswapV3Router.sol\";\nimport \"./stability-pool-base.sol\";\nimport \"./UniswapV3Arbitrage.sol\";\n\n/// @title is used to liquidate troves and reward depositors with collateral redeemed\ncontract StabilityPoolUniswap is StabilityPoolBase, IStabilityPoolUniswap, UniswapV3Arbitrage {\n  IUniswapV3Router public router;\n\n  constructor(address _factory, address _bonqToken) StabilityPoolBase(_factory, _bonqToken) {}\n\n  /// @dev use the DEX router to trigger a swap that starts and ends with the stable coin and yields more coins than it\n  /// @dev requied as input. This function could be subject to a reentrant attack from a malicious token in the DEX\n  /// @param  _amountIn start amount\n  /// @param  _path calldata[]\n  /// @param  _fees calldata[] fees array in correct order\n  function arbitrage(\n    uint256 _amountIn,\n    address[] calldata _path,\n    uint24[] calldata _fees,\n    uint256 _deadline\n  ) public override nonReentrant returns (uint256) {\n    uint256 startBalance;\n    uint256 amountOut;\n    amountOut = _arbitrage(router, _amountIn, _path, _fees, _deadline);\n    totalDeposit += amountOut;\n    // increase P by the arbitrage gain / total deposit\n    _updateP((amountOut * DECIMAL_PRECISION) / totalDeposit, false);\n    emit Arbitrage(_path, _amountIn, amountOut);\n    emit TotalDepositUpdated(totalDeposit);\n    return amountOut;\n  }\n\n  /// @dev set the DEX router to be used for arbitrage functions\n  function setRouter(address _router) public override onlyOwner {\n    router = IUniswapV3Router(_router);\n    stableCoin.approve(_router, MAX_INT);\n  }\n}\n"
    },
    "contracts/test/replacement-stability-pool-uniswap.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"../stability-pool-uniswap.sol\";\n\ncontract ReplacementStabilityPoolUniswap is StabilityPoolUniswap {\n  event NewReplacementEvent(string); // this\n\n  constructor(address _factory, address _bonqToken) StabilityPoolUniswap(_factory, _bonqToken) {}\n\n  /// test that we can update method\n  function setRouterNew(address _router) public onlyOwner {\n    router = IUniswapV3Router(_router);\n    stableCoin.approve(_router, MAX_INT);\n    emit NewReplacementEvent(\"Replacement test\"); // this\n  }\n}\n"
    },
    "contracts/interfaces/IStabilityPool.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IStabilityPoolBase.sol\";\n\ninterface IStabilityPool is IStabilityPoolBase {\n  function arbitrage(\n    uint256 _amountIn,\n    address[] calldata _path,\n    uint256 _deadline\n  ) external;\n\n  function setRouter(address _router) external;\n}\n"
    },
    "contracts/mintable-token-owner.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IMintableToken.sol\";\n\n/// @title implements owner of the MintableToken contract\ncontract MintableTokenOwner is Ownable {\n  IMintableToken public immutable token;\n  mapping(address => bool) public minters;\n\n  event MinterAdded(address newMinter);\n\n  // solhint-disable-next-line func-visibility\n  constructor(address _token) Ownable() {\n    token = IMintableToken(_token);\n  }\n\n  /// @dev mints tokens to the recipient, to be called from owner\n  /// @param _recipient address to mint\n  /// @param _amount amount to be minted\n  function mint(address _recipient, uint256 _amount) public {\n    require(minters[msg.sender], \"MintableTokenOwner:mint: the sender must be in the minters list\");\n    token.mint(_recipient, _amount);\n  }\n\n  function transferTokenOwnership(address _newOwner) public onlyOwner {\n    token.transferOwnership(_newOwner);\n  }\n\n  /// @dev adds new minter\n  /// @param _newMinter address of new minter\n  function addMinter(address _newMinter) public onlyOwner {\n    minters[_newMinter] = true;\n    emit MinterAdded(_newMinter);\n  }\n\n  /// @dev removes minter from minter list\n  /// @param _minter address of the minter\n  function revokeMinter(address _minter) public onlyOwner {\n    minters[_minter] = false;\n  }\n}\n"
    },
    "contracts/token-to-price-feed.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"./utils/constants.sol\";\nimport \"./interfaces/ITokenPriceFeed.sol\";\n\ncontract TokenToPriceFeed is Ownable, Constants, ITokenPriceFeed {\n  // the token list is a mapping from Token address to Price Feed address\n  mapping(address => TokenInfo) public tokens;\n\n  function owner() public view override(Ownable, IOwnable) returns (address) {\n    return Ownable.owner();\n  }\n\n  /// @dev to get token price\n  /// @param  _token address of the token\n  function tokenPrice(address _token) public view override returns (uint256) {\n    return IPriceFeed(tokens[_token].priceFeed).price();\n  }\n\n  function tokenPriceFeed(address _token) public view override returns (address) {\n    return tokens[_token].priceFeed;\n  }\n\n  function mcr(address _token) public view override returns (uint256) {\n    return tokens[_token].mcr;\n  }\n\n  function mrf(address _token) public view override returns (uint256) {\n    return tokens[_token].mrf;\n  }\n\n  /// @dev to set or change priceFeed contract for token\n  /// @param  _token address of the token\n  /// @param  _priceFeed address of the PriceFeed contract for token\n  /// @param  _mcr minimal collateral ratio of the token\n  /// @param  _maxRedemptionFeeBasisPoints maximum redemption fee in Basis Points or 100th of percent\n  function setTokenPriceFeed(\n    address _token,\n    address _priceFeed,\n    uint256 _mcr,\n    uint256 _maxRedemptionFeeBasisPoints\n  ) public override onlyOwner {\n    require(_mcr >= 100, \"f0925e MCR < 100\");\n    TokenInfo memory token = tokens[_token];\n    token.priceFeed = _priceFeed;\n    IERC20Metadata erc20 = IERC20Metadata(_token);\n    token.mcr = (DECIMAL_PRECISION * _mcr) / 100;\n    token.mrf = (_maxRedemptionFeeBasisPoints * DECIMAL_PRECISION) / 10000;\n    emit NewTokenPriceFeed(_token, _priceFeed, erc20.name(), erc20.symbol(), token.mcr, token.mrf);\n    tokens[_token] = token;\n  }\n\n  /**\n   * @dev transfers user's trove ownership after revoking other roles from other addresses\n   * @param _newOwner the address of the new owner\n   */\n  function transferOwnership(address _newOwner) public override(Ownable, IOwnable) {\n    Ownable.transferOwnership(_newOwner);\n  }\n\n  /// @dev to set or change priceFeed contract for token\n  /// @param  _token address of the token\n  /// @param  _priceAverage time weighed price average\n  /// @param  _pricePoint last price recorded to moving average\n  function emitPriceUpdate(\n    address _token,\n    uint256 _priceAverage,\n    uint256 _pricePoint\n  ) external override {\n    require(tokens[_token].priceFeed == msg.sender, \"e2b188 price feed not found in the list\");\n    emit PriceUpdate(_token, _priceAverage, _pricePoint);\n  }\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IPriceFeed {\n  function token() external view returns (address);\n\n  function price() external view returns (uint256);\n\n  function pricePoint() external view returns (uint256);\n\n  function emitPriceSignal() external;\n\n  event PriceUpdate(address token, uint256 price, uint256 average);\n}\n"
    },
    "contracts/test/test-price-feed.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/ITokenPriceFeed.sol\";\n\ncontract TestPriceFeed is IPriceFeed {\n  address public override token;\n  uint256 public override price;\n\n  // solhint-disable-next-line func-visibility\n  constructor(address _token) {\n    token = _token;\n    price = 10000000000000000000;\n  }\n\n  function setPrice(uint256 _price) public {\n    price = _price;\n  }\n\n  function update(bool savePrevious) public {}\n\n  function owner() public view returns (address) {\n    return address(tx.origin);\n  }\n\n  function pricePoint() external view override returns (uint256) {\n    return price;\n  }\n\n  function emitPriceSignal() public override {\n    emit PriceUpdate(token, price, price);\n  }\n}\n"
    },
    "contracts/price-feeds/tellor-price-feed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/ITokenPriceFeed.sol\";\n\ninterface ITellorFeed {\n  function getCurrentValue(bytes32 _queryId) external view returns (bytes calldata _value);\n}\n\ncontract TellorPriceFeed is IPriceFeed {\n  ITellorFeed public immutable oracle;\n  address public immutable override token;\n  bytes32 public immutable queryId;\n\n  constructor(\n    address _oracle,\n    address _token,\n    bytes32 _queryId\n  ) {\n    require(_oracle != address(0x0), \"e2637b _oracle must not be address 0x0\");\n    require(_token != address(0x0), \"e2637b _token must not be address 0x0\");\n    require(_queryId.length > 0, \"e2637b _queryId must not be 0 length\");\n\n    token = _token;\n    oracle = ITellorFeed(_oracle);\n    queryId = _queryId;\n  }\n\n  function price() public view virtual override returns (uint256) {\n    return uint256(bytes32(oracle.getCurrentValue(queryId)));\n  }\n\n  function pricePoint() public view override returns (uint256) {\n    return price();\n  }\n\n  function emitPriceSignal() public override {\n    emit PriceUpdate(token, price(), price());\n  }\n}\n"
    },
    "contracts/test/TellorDataFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"../price-feeds/tellor-price-feed.sol\";\n\ncontract TellorDataFeed is ITellorFeed {\n  function getCurrentValue(bytes32 _queryId) external view returns (bytes memory _value) {\n    return abi.encode(uint256(500000000000000000));\n  }\n}\n"
    },
    "contracts/price-feeds/chainlink-price-feed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/ITokenPriceFeed.sol\";\nimport \"../utils/constants.sol\";\n\ncontract ChainlinkPriceFeed is IPriceFeed, Constants {\n  AggregatorV2V3Interface public immutable oracle;\n  address public immutable override token;\n  uint256 public immutable precision;\n\n  constructor(address _oracle, address _token) {\n    require(_oracle != address(0x0), \"e2637b _oracle must not be address 0x0\");\n    require(_token != address(0x0), \"e2637b _token must not be address 0x0\");\n    token = _token;\n    oracle = AggregatorV2V3Interface(_oracle);\n    uint8 decimals = oracle.decimals();\n    require(decimals > 0, \"e2637b decimals must be a positive number\");\n    precision = 10**decimals;\n  }\n\n  function price() public view virtual override returns (uint256) {\n    return (uint256(oracle.latestAnswer()) * DECIMAL_PRECISION) / precision;\n  }\n\n  function pricePoint() public view override returns (uint256) {\n    return price();\n  }\n\n  function emitPriceSignal() public override {\n    emit PriceUpdate(token, price(), price());\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/price-feeds/converted-price-feed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./chainlink-price-feed.sol\";\n\ncontract ConvertedPriceFeed is IPriceFeed, Constants {\n  IPriceFeed public immutable priceFeed;\n  IPriceFeed public immutable conversionPriceFeed;\n  address public immutable override token;\n\n  constructor(\n    address _priceFeed,\n    address _conversionPriceFeed,\n    address _token\n  ) {\n    require(_priceFeed != address(0x0), \"e2637b _priceFeed must not be address 0x0\");\n    require(_conversionPriceFeed != address(0x0), \"e2637b _conversionPriceFeed must not be address 0x0\");\n    priceFeed = IPriceFeed(_priceFeed);\n    conversionPriceFeed = IPriceFeed(_conversionPriceFeed);\n    token = _token;\n  }\n\n  function price() public view override returns (uint256) {\n    return (priceFeed.price() * DECIMAL_PRECISION) / conversionPriceFeed.price();\n  }\n\n  function pricePoint() public view override returns (uint256) {\n    return price();\n  }\n\n  function emitPriceSignal() public {\n    emit PriceUpdate(token, price(), price());\n  }\n}\n"
    },
    "contracts/test/PriceAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\ncontract PriceAggregator is AggregatorV2V3Interface {\n  int256 public s_answer;\n  uint8 public override decimals;\n  string public override description = \"Test Price Aggregator\";\n  uint256 public override version = 12;\n\n  function setLatestAnswer(int256 answer) public {\n    s_answer = answer;\n  }\n\n  function setDecimals(uint8 _decimals) public {\n    decimals = _decimals;\n  }\n\n  function latestAnswer() public view override returns (int256) {\n    return s_answer;\n  }\n\n  function latestTimestamp() public view override returns (uint256) {\n    return block.timestamp;\n  }\n\n  function latestRound() public view override returns (uint256) {\n    return block.number;\n  }\n\n  function getAnswer(uint256 roundId) public view override returns (int256) {\n    return s_answer;\n  }\n\n  function getTimestamp(uint256 roundId) public view override returns (uint256) {\n    return block.timestamp;\n  }\n\n  function getRoundData(uint80 _roundId)\n    public\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    answer = latestAnswer();\n    roundId = 1;\n    startedAt = 1;\n    updatedAt = 2;\n    answeredInRound = 1;\n  }\n\n  function latestRoundData()\n    public\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return getRoundData(1);\n  }\n}\n"
    },
    "contracts/price-feeds/arrakis-vault-price-feed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport \"./chainlink-price-feed.sol\";\n\ninterface IArrakisVault is IERC20 {\n  function getUnderlyingBalances() external view returns (uint256 amount0Current, uint256 amount1Current);\n\n  function token0() external view returns (address);\n}\n\ncontract ArrakisVaultPriceFeed is IPriceFeed, Constants {\n  IArrakisVault public immutable vault;\n  // token must be implemented by pricefeed and it will be cheapest as an immutable\n  address public immutable override token;\n  IPriceFeed public immutable priceFeed;\n  bool public immutable isToken0;\n  uint256 public immutable precision;\n\n  constructor(address _vault, address _priceFeed) {\n    require(_vault != address(0x0), \"e2637b vault must not be address 0x0\");\n    require(_priceFeed != address(0x0), \"e2637b priceFeed must not be address 0x0\");\n    vault = IArrakisVault(_vault);\n    address _token = IPriceFeed(_priceFeed).token();\n    token = _vault;\n    priceFeed = IPriceFeed(_priceFeed);\n    isToken0 = IArrakisVault(_vault).token0() == _token;\n    precision = 10**IERC20Metadata(_token).decimals();\n  }\n\n  function price() public view override returns (uint256) {\n    uint256 avTokenSupply = vault.totalSupply();\n    (uint256 t0Balance, uint256 t1Balance) = vault.getUnderlyingBalances();\n    // normalise balance to 18 decimals\n    uint256 tBalance = ((isToken0 ? t0Balance : t1Balance) * DECIMAL_PRECISION) / precision;\n    return (priceFeed.price() * tBalance) / avTokenSupply;\n  }\n\n  function pricePoint() public view override returns (uint256) {\n    return price();\n  }\n\n  function emitPriceSignal() public {\n    emit PriceUpdate(token, price(), price());\n  }\n}\n"
    },
    "contracts/test/arrakis-vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../price-feeds/arrakis-vault-price-feed.sol\";\nimport \"./TestMintableToken.sol\";\nimport \"../utils/constants.sol\";\n\ncontract ArrakisVaultUSDC is IArrakisVault, TestMintableToken, Constants {\n  address public override token0;\n\n  constructor(address _token0) TestMintableToken(\"Arrakis AP Token BEUR/USDC\", \"ALBU\") {\n    mint(msg.sender, DECIMAL_PRECISION * 1000);\n    token0 = _token0;\n  }\n\n  function getUnderlyingBalances() public view override returns (uint256 amount0Current, uint256 amount1Current) {\n    // USDC has 6 decimals\n    amount0Current = 10**6 * 800;\n    amount1Current = DECIMAL_PRECISION * 1000;\n  }\n}\n\ncontract ArrakisVaultWETH is IArrakisVault, TestMintableToken, Constants {\n  address public override token0;\n\n  constructor(address _token0) TestMintableToken(\"Arrakis AP Token BEUR/WETH\", \"ALBE\") {\n    mint(msg.sender, DECIMAL_PRECISION * 1000);\n    token0 = _token0;\n  }\n\n  function getUnderlyingBalances() public view returns (uint256 amount0Current, uint256 amount1Current) {\n    amount0Current = DECIMAL_PRECISION * 1000;\n    amount1Current = DECIMAL_PRECISION * 80;\n  }\n}\n"
    },
    "contracts/test/TestMintableToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title implements minting/burning functionality for owner\ncontract TestMintableToken is ERC20, Ownable {\n  uint8 private _decimals = 18;\n\n  // solhint-disable-next-line func-visibility\n  constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n  /// @dev mints tokens to the recipient, to be called from owner\n  /// @param recipient address to mint\n  /// @param amount amount to be minted\n  function mint(address recipient, uint256 amount) public {\n    _mint(recipient, amount);\n  }\n\n  /// @dev burns token of specified amount from msg.sender\n  /// @param amount to burn\n  function burn(uint256 amount) public {\n    _burn(msg.sender, amount);\n  }\n\n  function setDecimals(uint8 _newDecimals) public {\n    _decimals = _newDecimals;\n  }\n\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n}\n"
    },
    "contracts/test/malicious-arbitrage-token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IArbitragePool.sol\";\nimport \"../utils/constants.sol\";\n\n/// @title implements minting/burning functionality for owner\ncontract MaliciousArbitrageToken is ERC20, Ownable, Constants {\n  address public arbitrage;\n  address public troveToken;\n  address public apToken;\n  uint8 level;\n\n  event Attack(uint8 step);\n  event ArbitrageSet();\n\n  // solhint-disable-next-line func-visibility\n  constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n  function setArbitrage(\n    address _arbitrage,\n    address _troveToken,\n    address _apToken\n  ) public {\n    arbitrage = _arbitrage;\n    troveToken = _troveToken;\n    apToken = _apToken;\n    ERC20(_troveToken).approve(arbitrage, MAX_INT);\n    emit ArbitrageSet();\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public override returns (bool) {\n    return ERC20.transferFrom(from, to, amount);\n  }\n\n  function transfer(address to, uint256 amount) public override returns (bool) {\n    emit Attack(1);\n    if (arbitrage != address(0x0)) {\n      emit Attack(2);\n      IArbitragePool(arbitrage).deposit(troveToken, 10 * DECIMAL_PRECISION);\n      emit Attack(3);\n      require(IERC20(apToken).balanceOf(address(this)) > 0, \"AP token must have been minted\");\n    } else {\n      emit Attack(0);\n    }\n    return ERC20.transfer(to, amount);\n  }\n\n  /// @dev mints tokens to the recipient, to be called from owner\n  /// @param recipient address to mint\n  /// @param amount amount to be minted\n  function mint(address recipient, uint256 amount) public {\n    _mint(recipient, amount);\n  }\n\n  /// @dev burns token of specified amount from msg.sender\n  /// @param amount to burn\n  function burn(uint256 amount) public {\n    _burn(msg.sender, amount);\n  }\n}\n"
    },
    "contracts/service-fee-generator.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"./interfaces/IServiceFeeGenerator.sol\";\nimport \"./interfaces/ITrove.sol\";\nimport \"./interfaces/IFeeRecipient.sol\";\nimport \"./utils/constants.sol\";\n\ncontract ServiceFeeGenerator is IServiceFeeGenerator, Initializable, Constants {\n  ITroveFactory public immutable factory;\n  ITrove public override trove;\n  IFeeRecipient public override feeRecipient;\n  uint256 public override feeAmount;\n  uint256 public override feeInterval;\n  bool public override initialized;\n\n  uint256 public override lastPayTime;\n\n  constructor(address _factory) {\n    factory = ITroveFactory(_factory);\n  }\n\n  function initialize(\n    ITrove _trove,\n    uint256 _feeAmount,\n    uint256 _feeInterval\n  ) public override initializer {\n    require(_feeAmount >= DECIMAL_PRECISION, \"da69e0 fee amount must be gte 1 BEUR\");\n    require(_trove.hasRole(_trove.OWNER_ROLE(), address(this)), \"da69e0 ownership is not granted\");\n    trove = _trove;\n    feeAmount = _feeAmount;\n    feeInterval = _feeInterval;\n    initialized = true;\n    feeRecipient = factory.feeRecipient();\n    factory.stableCoin().approve(address(feeRecipient), MAX_INT);\n    lastPayTime = block.timestamp - _feeInterval;\n    emit Activated(_trove.owner(), address(_trove), _feeAmount, _feeInterval);\n  }\n\n  function isPaid() external view override returns (bool) {\n    return lastPayTime + feeInterval > block.timestamp;\n  }\n\n  /**\n     * @dev is called to transfer the fees to FeeRecipient when the interval time has passed. It will borrow on the trove to get the\n     fees from the msg.sender\n     The withdrawFee function must be called for each period. There is no compounding of fees\n     * @param _newNextTrove hint for next position (same as for borrowing on trove)\n     */\n  function withdrawFee(address _newNextTrove) external override {\n    require(initialized, \"c93e1f contract must be initialized\");\n    require(this.isPaid() == false, \"c93e1f fee is paid for current period\");\n    lastPayTime += feeInterval;\n    trove.borrow(address(this), feeAmount, _newNextTrove);\n    feeRecipient.takeFees(feeAmount);\n\n    emit FeeCollected(lastPayTime - feeInterval, lastPayTime);\n  }\n}\n"
    },
    "contracts/test/fee-recipient.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../utils/constants.sol\";\nimport \"../interfaces/IFeeRecipient.sol\";\n\ncontract TestFeeRecipient is IFeeRecipient, Constants {\n  IERC20 public feeToken;\n  uint256 public override baseRate;\n\n  // solhint-disable-next-line func-visibility\n  constructor(address _feeToken) {\n    feeToken = IERC20(_feeToken);\n  }\n\n  function calcDecayedBaseRate(uint256 _amount) public pure override returns (uint256) {\n    return (_amount * ((DECIMAL_PRECISION * 5) / 1000)) / DECIMAL_PRECISION;\n  }\n\n  function getBorrowingFee(uint256 _amount) external view override returns (uint256) {\n    return (_amount * (baseRate + ((DECIMAL_PRECISION * 5) / 1000))) / DECIMAL_PRECISION;\n  }\n\n  function takeFees(uint256 _amount) public override returns (bool) {\n    return feeToken.transferFrom(msg.sender, address(this), _amount);\n  }\n\n  function increaseBaseRate(uint256 _increase) external override returns (uint256) {\n    baseRate += _increase;\n    return baseRate;\n  }\n}\n"
    },
    "contracts/test/test-router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../utils/constants.sol\";\nimport \"../interfaces/IRouter.sol\";\n\ncontract TestRouter is Constants {\n  event SwapToken(address token, uint256 balance, address thisAddress);\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) public {\n    for (uint256 i = 0; i < path.length - 1; i++) {\n      IERC20 token = IERC20(path[i]);\n      token.transfer(msg.sender, DECIMAL_PRECISION);\n      emit SwapToken(path[i], token.balanceOf(address(this)), address(this));\n    }\n  }\n}\n"
    },
    "contracts/community-liquidation-pool.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./interfaces/ILiquidationPool.sol\";\nimport \"./interfaces/ITroveFactory.sol\";\nimport \"./interfaces/ITrove.sol\";\nimport \"./interfaces/IMintableToken.sol\";\n\n/// @title is used in case when stabilityPool is empty or not enough to liquidate trove\ncontract CommunityLiquidationPool is ILiquidationPool, Constants {\n  using SafeERC20 for IERC20;\n  ITroveFactory public immutable factory;\n  uint256 public override liqTokenRate = DECIMAL_PRECISION;\n  uint256 public override collateral;\n  uint256 public override debt;\n  IERC20 public immutable collateralToken;\n\n  // solhint-disable-next-line func-visibility\n  constructor(address _factory, address _token) {\n    require(_factory != address(0x0) && _token != address(0x0), \"65151f no zero addresses\");\n    factory = ITroveFactory(_factory);\n    collateralToken = IERC20(_token);\n  }\n\n  /// @dev to approve trove, and let it liquidate itself further\n  /// @param _trove address of the trove\n  function approveTrove(address _trove) public override {\n    require(msg.sender == address(factory), \"1b023 only the factory is allowed to call\");\n    collateralToken.approve(_trove, MAX_INT);\n  }\n\n  /// @dev to unapprove trove, forbid it to liquidate itself further\n  /// @param _trove address of the trove\n  function unapproveTrove(address _trove) public override {\n    require(msg.sender == address(factory), \"cfec3 only the factory is allowed to call\");\n    collateralToken.approve(_trove, 0);\n  }\n\n  /// @dev to transfer collateral and decrease collateral and debt in the pool\n  /// @param _unclaimedCollateral unclaimed collateral calculated in the trove\n  /// @param _unclaimedDebt the unclaimed debt calculated in the trove\n  function claimCollateralAndDebt(uint256 _unclaimedCollateral, uint256 _unclaimedDebt) external override {\n    IERC20 tokenCache = collateralToken;\n    require(factory.containsTrove(address(tokenCache), msg.sender), \"c0e31 must be called from a valid trove\");\n    collateral -= _unclaimedCollateral;\n    debt -= _unclaimedDebt;\n\n    tokenCache.safeTransfer(msg.sender, _unclaimedCollateral);\n  }\n\n  /// @dev liquidates the trove that called it\n  function liquidate() external override {\n    ITroveFactory factoryCache = factory;\n    IERC20 tokenCache = collateralToken;\n    require(factoryCache.troveCount(address(tokenCache)) > 1, \"c0e35 the last trove can not be liquidated\");\n    require(factoryCache.containsTrove(address(tokenCache), msg.sender), \"c0e35 must be called from a valid trove\");\n    ITrove trove = ITrove(msg.sender);\n    uint256 troveCollateral = trove.recordedCollateral();\n    collateral += troveCollateral;\n    debt += trove.debt();\n    uint256 factoryCollateral = factoryCache.totalCollateral(address(tokenCache));\n    liqTokenRate += (troveCollateral * liqTokenRate) / (factoryCollateral - troveCollateral); // = (FactoryCollateral / prevLiqCollateral)\n\n    tokenCache.safeTransferFrom(msg.sender, address(this), troveCollateral);\n\n    factoryCache.emitLiquidationEvent(address(tokenCache), msg.sender, address(0), troveCollateral);\n  }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/bonq-proxy.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\n// import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\ncontract BonqProxy is ERC1967Proxy {\n  constructor(address _logic, bytes memory _data) payable ERC1967Proxy(_logic, _data) {}\n}\n"
    },
    "contracts/BONQ-staking.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./interfaces/IBONQStaking.sol\";\nimport \"./interfaces/IFeeRecipient.sol\";\nimport \"./interfaces/ITroveFactory.sol\";\nimport \"./interfaces/ITrove.sol\";\nimport \"./utils/BONQMath.sol\";\n\n/// @title BONQ Staking contract, rewards stakers in StableCoin that is used to pay fee\ncontract BONQStaking is IBONQStaking, IFeeRecipient, OwnableUpgradeable, UUPSUpgradeable, Constants {\n  using BONQMath for uint256;\n  // --- Data ---\n  string public constant NAME = \"BONQStaking\";\n  // constants\n\n  uint256 public override baseRate;\n\n  uint256 public minuteDecayFactor;\n  uint256 public beta;\n  uint256 public alpha;\n  uint256 public maxFeeCollateralRatio;\n\n  mapping(address => uint256) public stakes;\n  uint256 public totalBONQStaked;\n\n  uint256 public F_StableCoin; // Running sum of StableCoin fees per-BONQ-staked\n  uint256 public lastFeeOperationTime;\n\n  // User snapshots of F_BONQ and F_StableCoin, taken at the point at which their latest deposit was made\n  mapping(address => uint256) public F_StableCoinSnapshots;\n  mapping(address => uint256) public stableCoinUserGains;\n\n  ITroveFactory public factory;\n  IERC20 public bonqToken;\n  IERC20 public stableCoin;\n\n  // --- Events ---\n\n  event FactoryAddressSet(address _factoryAddress);\n  event BonqTokenAddressSet(address _bonqTokenAddress);\n  event StableCoinAddressSet(address _stableCoinAddress);\n\n  event StakeChanged(address indexed _staker, uint256 _newStake);\n  event TotalBONQStakedUpdated(uint256 _totalBONQStaked);\n  event RewardRedeemed(address _account, uint256 _stableAmount, address _troveAddress);\n  event StakerSnapshotsUpdated(address _staker, uint256 _F_StableCoin, uint256 _stableGains);\n  event FeeTaken(uint256 _amount, uint256 _F_StableCoin, bool _redemptionFee);\n\n  constructor() {\n    // to prevent contract implementation to be reinitialized by someone else\n    _disableInitializers();\n  }\n\n  function initialize(address _bonqToken) public initializer {\n    __Ownable_init();\n    minuteDecayFactor = 999037758833783000;\n    beta = 25000000000000000000;\n    alpha = 56000000000000000;\n    maxFeeCollateralRatio = 5100000000000000000;\n    bonqToken = IERC20(_bonqToken);\n  }\n\n  // for UUPS implementation\n  function _authorizeUpgrade(address) internal override onlyOwner {}\n\n  function name() public view virtual returns (string memory) {\n    return NAME;\n  }\n\n  // --- Functions ---\n\n  /// @dev set the new fee decay factor per minute\n  /// @param _newMinuteDecayFactor uint256 value\n  function setMinuteDecayFactor(uint256 _newMinuteDecayFactor) public onlyOwner {\n    minuteDecayFactor = _newMinuteDecayFactor;\n  }\n\n  /// @dev set the new alpha value\n  /// @param _alpha uint256 value\n  function setAlphaValue(uint256 _alpha) public onlyOwner {\n    alpha = _alpha;\n  }\n\n  /// @dev set the new beta value\n  /// @param _beta uint256 value\n  function setBetaValue(uint256 _beta) public onlyOwner {\n    beta = _beta;\n  }\n\n  /// @dev set the maximum Collateral Ratio threshold to return 100% feeRatio\n  /// @param _maxFeeCollateralRatio uint256 value\n  function setMaxFeeCollateralRatio(uint256 _maxFeeCollateralRatio) public onlyOwner {\n    maxFeeCollateralRatio = _maxFeeCollateralRatio;\n  }\n\n  /// @dev set timestamp to calculate next decayed rate from\n  /// @param _timestamp uint256 in seconds\n  function setInitialLastFee(uint256 _timestamp) public onlyOwner {\n    lastFeeOperationTime = _timestamp > 0 ? _timestamp : block.timestamp;\n  }\n\n  /// @dev calculates the rate dacayed by time passed since last fee, uses `decPow` from BONQMath\n  /// @param _currentBaseRate current rate to decay\n  /// @return uint256 decayed baseRate in uint256\n  function calcDecayedBaseRate(uint256 _currentBaseRate) public view override returns (uint256) {\n    if (_currentBaseRate == 0) {\n      return 0;\n    }\n    uint256 minutesPassed = (block.timestamp - lastFeeOperationTime) / (1 minutes);\n    // The _decPow function is a custom function\n    uint256 decayFactor = BONQMath._decPow(minuteDecayFactor, minutesPassed);\n    return (_currentBaseRate * decayFactor) / DECIMAL_PRECISION;\n  }\n\n  /// @dev returns fee from borrowing the amount\n  /// @param _amount amount to borrow\n  /// @return uint256 resulting fee\n  function getBorrowingFee(uint256 _amount) public view override returns (uint256) {\n    return\n      (_amount * BONQMath.min(MAX_BORROWING_RATE, (PERCENT_05 + calcDecayedBaseRate(baseRate)))) / DECIMAL_PRECISION;\n  }\n\n  /// @dev sets the TroveFactory contract, if address was updated\n  function setFactory(address _factoryAddress) external onlyOwner {\n    factory = ITroveFactory(_factoryAddress);\n    stableCoin = IERC20(address(factory.stableCoin()));\n    emit FactoryAddressSet(address(factory));\n    emit StableCoinAddressSet(address(stableCoin));\n  }\n\n  /// @dev sets the StableCoin token contract, if address was updated\n  function updateStableCoin() external {\n    require(address(factory.stableCoin()) != address(stableCoin), \"4e1ea nothing to update\");\n    stableCoin = IERC20(address(factory.stableCoin()));\n    emit StableCoinAddressSet(address(stableCoin));\n  }\n\n  /// @dev to stake BONQ\n  /// @param _bonqAmount amount of BONQ to stake\n  /// @notice If caller has a pre-existing stake, records any accumulated StableCoin gains to them.\n  function stake(uint256 _bonqAmount) external override {\n    _requireNonZeroAmount(_bonqAmount);\n\n    uint256 currentStake = stakes[msg.sender];\n\n    // Transfer BONQ from caller to this contract\n    require(bonqToken.transferFrom(msg.sender, address(this), _bonqAmount), \"4e1ea transfer from failed\");\n\n    // Grab and record accumulated StableCoin gains from the current stake and update Snapshot\n    uint256 currentTotalBONQStaked = totalBONQStaked;\n    if (currentTotalBONQStaked == 0) stableCoinUserGains[msg.sender] += F_StableCoin;\n    _updateUserSnapshot(msg.sender);\n\n    // Increase user’s stake and total BONQ staked\n    uint256 newTotalBONQStaked = currentTotalBONQStaked + _bonqAmount;\n    totalBONQStaked = newTotalBONQStaked;\n    uint256 newUserStake = currentStake + _bonqAmount;\n    stakes[msg.sender] = newUserStake;\n\n    emit TotalBONQStakedUpdated(newTotalBONQStaked);\n    emit StakeChanged(msg.sender, newUserStake);\n  }\n\n  /// @dev to unstake BONQ\n  /// @param _bonqAmount amount of BONQ to unstake\n  /// @notice Unstake the BONQ and send the it back to the caller, and record accumulated StableCoin gains.\n  /// If requested amount > stake, send their entire stake.\n  function unstake(uint256 _bonqAmount) external override {\n    _requireNonZeroAmount(_bonqAmount);\n    uint256 currentStake = stakes[msg.sender];\n    _requireUserHasStake(currentStake);\n\n    // Grab and record accumulated StableCoin gains from the current stake and update Snapshot\n    _updateUserSnapshot(msg.sender);\n\n    uint256 BONQToWithdraw = _bonqAmount.min(currentStake);\n\n    uint256 newStake = currentStake - BONQToWithdraw;\n\n    // Decrease user's stake and total BONQ staked\n    stakes[msg.sender] = newStake;\n    totalBONQStaked = totalBONQStaked - BONQToWithdraw;\n    emit TotalBONQStakedUpdated(totalBONQStaked);\n\n    // Transfer unstaked BONQ to user\n    bonqToken.transfer(msg.sender, BONQToWithdraw);\n\n    emit StakeChanged(msg.sender, newStake);\n  }\n\n  // --- Reward-per-unit-staked increase functions. Called by BONQ core contracts ---\n\n  /// @dev to pay fee in StableCoin, transfer the amount specified\n  /// @param _amount amount of StableCoin to pay as fee\n  /// @notice Unstake the BONQ and send the it back to the caller, and record accumulated StableCoin gains.\n  /// If requested amount > stake, send their entire stake.\n  function takeFees(uint256 _amount) external override returns (bool) {\n    _requireNonZeroAmount(_amount);\n    stableCoin.transferFrom(msg.sender, address(this), _amount);\n    uint256 totalBONQStaked_cached = totalBONQStaked;\n    uint256 amountPerBONQStaked = _amount;\n    if (totalBONQStaked_cached > 0) {\n      amountPerBONQStaked = ((_amount) * DECIMAL_PRECISION) / totalBONQStaked_cached;\n    }\n    uint256 newF_StableCoin = F_StableCoin + amountPerBONQStaked;\n    F_StableCoin = newF_StableCoin;\n\n    if (baseRate > 0) {\n      lastFeeOperationTime = block.timestamp;\n      baseRate = calcDecayedBaseRate(baseRate);\n    }\n    emit FeeTaken(_amount, newF_StableCoin, msg.sender == address(factory));\n    return true;\n  }\n\n  /// @dev updates baseRate\n  /// @param _increase value to add to baseRate\n  /// @notice _increase\n  function increaseBaseRate(uint256 _increase) external override returns (uint256) {\n    require(msg.sender == address(factory), \"10bcb only factory increases baseRate\");\n    lastFeeOperationTime = block.timestamp;\n    baseRate += _increase;\n    return baseRate;\n  }\n\n  // --- Pending reward functions ---\n\n  /// @dev to redeem StableCoin rewards, transfers the amount only to repay debt of the Trove\n  /// @param _amount amount of StableCoin to repay the debt\n  /// @param _troveAddress address of the valid trove to repay the debt\n  /// @param _newNextTrove hint for the newNextTrove position (next trove)\n  /// @notice user can redeem StableCoin rewards only to repay the debt of the troves\n  function redeemReward(\n    uint256 _amount,\n    address _troveAddress,\n    address _newNextTrove\n  ) external override {\n    _requireNonZeroAmount(_amount);\n    address account = msg.sender;\n    ITrove trove = ITrove(_troveAddress);\n    require(factory.containsTrove(address(trove.token()), _troveAddress), \"2ff8c must be called for a valid trove\");\n    _amount = trove.netDebt().min(_amount);\n    require((_getUnpaidStableCoinGain(msg.sender)) >= _amount, \"2ff8c _amount must fit rewards amount\");\n    _updateUserSnapshot(account);\n    stableCoinUserGains[account] = stableCoinUserGains[account] - _amount;\n    // TODO: check how much gas can be saved by storing the approved troves in a mapping\n    // TODO: check the gas difference in using transfer instead of transferFrom for repayment\n    if (stableCoin.allowance(address(this), address(trove)) < _amount) {\n      stableCoin.approve(address(trove), MAX_INT);\n    }\n    trove.repay(_amount, _newNextTrove);\n    emit RewardRedeemed(msg.sender, _amount, _troveAddress);\n  }\n\n  /// @dev to get total BONQ stkae amount\n  function totalStake() external view override returns (uint256) {\n    return totalBONQStaked;\n  }\n\n  /// @dev reads the unpaid rewards of the user\n  /// @param _user the user to check\n  function getUnpaidStableCoinGain(address _user) external view override returns (uint256) {\n    return _getUnpaidStableCoinGain(_user);\n  }\n\n  /// @dev reads the unpaid rewards of the user\n  function getRewardsTotal() external view override returns (uint256) {\n    return F_StableCoin;\n  }\n\n  // --- Internal helper functions ---\n\n  function _getPendingStableCoinGain(address _user) internal view returns (uint256) {\n    uint256 F_StableCoin_Snapshot = F_StableCoinSnapshots[_user];\n    uint256 stableCoinGain = (stakes[_user] * (F_StableCoin - F_StableCoin_Snapshot)) / DECIMAL_PRECISION;\n    return stableCoinGain;\n  }\n\n  function _getUnpaidStableCoinGain(address _user) internal view returns (uint256) {\n    return stableCoinUserGains[_user] + _getPendingStableCoinGain(_user);\n  }\n\n  function _recordStableCoinGain(address _user) internal {\n    uint256 userStake = stakes[_user];\n    if (userStake > 0) {\n      uint256 F_StableCoin_Snapshot = F_StableCoinSnapshots[_user];\n      uint256 stableCoinGain = (userStake * (F_StableCoin - F_StableCoin_Snapshot)) / DECIMAL_PRECISION;\n      stableCoinUserGains[_user] += stableCoinGain;\n    }\n  }\n\n  function _updateUserSnapshot(address _user) internal {\n    _recordStableCoinGain(_user);\n    uint256 currentF_StableCoin = F_StableCoin;\n    F_StableCoinSnapshots[_user] = currentF_StableCoin;\n    emit StakerSnapshotsUpdated(_user, currentF_StableCoin, stableCoinUserGains[_user]);\n  }\n\n  // --- 'require' functions ---\n\n  function _requireUserHasStake(uint256 currentStake) internal pure {\n    require(currentStake > 0, \"fcdb3 User must have a non-zero stake\");\n  }\n\n  function _requireNonZeroAmount(uint256 _amount) internal pure {\n    require(_amount > 0, \"8c64b Amount must be non-zero\");\n  }\n}\n"
    },
    "contracts/test/replacement-BONQ-staking.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../BONQ-staking.sol\";\n\ncontract ReplacementBONQStaking is BONQStaking {\n  function name() public view override returns (string memory) {\n    return \"ReplacementBONQStaking\";\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/uniswap/periphery/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\nimport \"./IPoolInitializer.sol\";\nimport \"./IERC721Permit.sol\";\nimport \"./IPeripheryPayments.sol\";\nimport \"./IPeripheryImmutableState.sol\";\nimport \"../../../utils/PoolAddress.sol\";\n\n/// @title Non-fungible token for positions\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\ninterface INonfungiblePositionManager is\n  IPoolInitializer,\n  IPeripheryPayments,\n  IPeripheryImmutableState,\n  IERC721Metadata,\n  IERC721Enumerable,\n  IERC721Permit\n{\n  /// @notice Emitted when liquidity is increased for a position NFT\n  /// @dev Also emitted when a token is minted\n  /// @param tokenId The ID of the token for which liquidity was increased\n  /// @param liquidity The amount by which liquidity for the NFT position was increased\n  /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n  /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n  event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n  /// @notice Emitted when liquidity is decreased for a position NFT\n  /// @param tokenId The ID of the token for which liquidity was decreased\n  /// @param liquidity The amount by which liquidity for the NFT position was decreased\n  /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\n  /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\n  event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n  /// @notice Emitted when tokens are collected for a position NFT\n  /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\n  /// @param tokenId The ID of the token for which underlying tokens were collected\n  /// @param recipient The address of the account that received the collected tokens\n  /// @param amount0 The amount of token0 owed to the position that was collected\n  /// @param amount1 The amount of token1 owed to the position that was collected\n  event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\n\n  /// @notice Returns the position information associated with a given token ID.\n  /// @dev Throws if the token ID is not valid.\n  /// @param tokenId The ID of the token that represents the position\n  /// @return nonce The nonce for permits\n  /// @return operator The address that is approved for spending\n  /// @return token0 The address of the token0 for a specific pool\n  /// @return token1 The address of the token1 for a specific pool\n  /// @return fee The fee associated with the pool\n  /// @return tickLower The lower end of the tick range for the position\n  /// @return tickUpper The higher end of the tick range for the position\n  /// @return liquidity The liquidity of the position\n  /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n  /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n  /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n  /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n  function positions(uint256 tokenId)\n    external\n    view\n    returns (\n      uint96 nonce,\n      address operator,\n      address token0,\n      address token1,\n      uint24 fee,\n      int24 tickLower,\n      int24 tickUpper,\n      uint128 liquidity,\n      uint256 feeGrowthInside0LastX128,\n      uint256 feeGrowthInside1LastX128,\n      uint128 tokensOwed0,\n      uint128 tokensOwed1\n    );\n\n  struct MintParams {\n    address token0;\n    address token1;\n    uint24 fee;\n    int24 tickLower;\n    int24 tickUpper;\n    uint256 amount0Desired;\n    uint256 amount1Desired;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Creates a new position wrapped in a NFT\n  /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n  /// a method does not exist, i.e. the pool is assumed to be initialized.\n  /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n  /// @return tokenId The ID of the token that represents the minted position\n  /// @return liquidity The amount of liquidity for this position\n  /// @return amount0 The amount of token0\n  /// @return amount1 The amount of token1\n  function mint(MintParams calldata params)\n    external\n    payable\n    returns (\n      uint256 tokenId,\n      uint128 liquidity,\n      uint256 amount0,\n      uint256 amount1\n    );\n\n  struct IncreaseLiquidityParams {\n    uint256 tokenId;\n    uint256 amount0Desired;\n    uint256 amount1Desired;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    uint256 deadline;\n  }\n\n  /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n  /// @param params tokenId The ID of the token for which liquidity is being increased,\n  /// amount0Desired The desired amount of token0 to be spent,\n  /// amount1Desired The desired amount of token1 to be spent,\n  /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n  /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n  /// deadline The time by which the transaction must be included to effect the change\n  /// @return liquidity The new liquidity amount as a result of the increase\n  /// @return amount0 The amount of token0 to acheive resulting liquidity\n  /// @return amount1 The amount of token1 to acheive resulting liquidity\n  function increaseLiquidity(IncreaseLiquidityParams calldata params)\n    external\n    payable\n    returns (\n      uint128 liquidity,\n      uint256 amount0,\n      uint256 amount1\n    );\n\n  struct DecreaseLiquidityParams {\n    uint256 tokenId;\n    uint128 liquidity;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    uint256 deadline;\n  }\n\n  /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n  /// @param params tokenId The ID of the token for which liquidity is being decreased,\n  /// amount The amount by which liquidity will be decreased,\n  /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n  /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n  /// deadline The time by which the transaction must be included to effect the change\n  /// @return amount0 The amount of token0 accounted to the position's tokens owed\n  /// @return amount1 The amount of token1 accounted to the position's tokens owed\n  function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n    external\n    payable\n    returns (uint256 amount0, uint256 amount1);\n\n  struct CollectParams {\n    uint256 tokenId;\n    address recipient;\n    uint128 amount0Max;\n    uint128 amount1Max;\n  }\n\n  /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n  /// @param params tokenId The ID of the NFT for which tokens are being collected,\n  /// recipient The account that should receive the tokens,\n  /// amount0Max The maximum amount of token0 to collect,\n  /// amount1Max The maximum amount of token1 to collect\n  /// @return amount0 The amount of fees collected in token0\n  /// @return amount1 The amount of fees collected in token1\n  function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n  /// must be collected first.\n  /// @param tokenId The ID of the token that is being burned\n  function burn(uint256 tokenId) external payable;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/uniswap/periphery/IPoolInitializer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\n/// @title Creates and initializes V3 Pools\n/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that\n/// require the pool to exist.\ninterface IPoolInitializer {\n  /// @notice Creates a new pool if it does not exist, then initializes if not initialized\n  /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\n  /// @param token0 The contract address of token0 of the pool\n  /// @param token1 The contract address of token1 of the pool\n  /// @param fee The fee amount of the v3 pool for the specified token pair\n  /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\n  /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\n  function createAndInitializePoolIfNecessary(\n    address token0,\n    address token1,\n    uint24 fee,\n    uint160 sqrtPriceX96\n  ) external payable returns (address pool);\n}\n"
    },
    "contracts/interfaces/uniswap/periphery/IERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/// @title ERC721 with permit\n/// @notice Extension to ERC721 that includes a permit function for signature based approvals\ninterface IERC721Permit is IERC721 {\n  /// @notice The permit typehash used in the permit signature\n  /// @return The typehash for the permit\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  /// @notice The domain separator used in the permit signature\n  /// @return The domain seperator used in encoding of permit signature\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /// @notice Approve of a specific token ID for spending by spender via signature\n  /// @param spender The account that is being approved\n  /// @param tokenId The ID of the token that is being approved for spending\n  /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n  /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n  /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n  /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n  function permit(\n    address spender,\n    uint256 tokenId,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external payable;\n}\n"
    },
    "contracts/interfaces/uniswap/periphery/IPeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPayments {\n  /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n  /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n  /// @param amountMinimum The minimum amount of WETH9 to unwrap\n  /// @param recipient The address receiving ETH\n  function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n\n  /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n  /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n  /// that use ether for the input amount\n  function refundETH() external payable;\n\n  /// @notice Transfers the full amount of a token held by this contract to recipient\n  /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n  /// @param token The contract address of the token which will be transferred to `recipient`\n  /// @param amountMinimum The minimum amount of token required for a transfer\n  /// @param recipient The destination address of the token\n  function sweepToken(\n    address token,\n    uint256 amountMinimum,\n    address recipient\n  ) external payable;\n}\n"
    },
    "contracts/interfaces/uniswap/periphery/IPeripheryImmutableState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\n/// @title Immutable state\n/// @notice Functions that return immutable state of the router\ninterface IPeripheryImmutableState {\n  /// @return Returns the address of the Uniswap V3 factory\n  function factory() external view returns (address);\n\n  /// @return Returns the address of WETH9\n  function WETH9() external view returns (address);\n}\n"
    },
    "contracts/utils/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n  bytes32 internal constant POOL_INIT_CODE_HASH = 0x5fd83e37b194e20b4858ffd8707ab464489099cc00c7985c0a048fa38836bbaa;\n\n  /// @notice The identifying key of the pool\n  struct PoolKey {\n    address token0;\n    address token1;\n    uint24 fee;\n  }\n\n  /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n  /// @param tokenA The first token of a pool, unsorted\n  /// @param tokenB The second token of a pool, unsorted\n  /// @param fee The fee level of the pool\n  /// @return Poolkey The pool details with ordered token0 and token1 assignments\n  function getPoolKey(\n    address tokenA,\n    address tokenB,\n    uint24 fee\n  ) internal pure returns (PoolKey memory) {\n    if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n    return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n  }\n\n  /// @notice Deterministically computes the pool address given the factory and PoolKey\n  /// @param factory The Uniswap V3 factory contract address\n  /// @param key The PoolKey\n  /// @return pool The contract address of the V3 pool\n  function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n    require(key.token0 < key.token1);\n    pool = address(\n      uint160(\n        uint256(\n          keccak256(\n            abi.encodePacked(\n              hex\"ff\",\n              factory,\n              keccak256(abi.encode(key.token0, key.token1, key.fee)),\n              POOL_INIT_CODE_HASH\n            )\n          )\n        )\n      )\n    );\n  }\n}\n"
    },
    "contracts/splittable-token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\n//import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title implements minting/burning functionality for owner\ncontract SplittableToken is ERC20, Ownable {\n  uint256 public initialSupply;\n  uint256 private _precision = 1e18;\n  uint256 public multiplier = 1e18;\n  mapping(address => uint256) public userMultipliers;\n\n  event IncreaseSupply(uint256 multiplier, uint256 increase);\n\n  // solhint-disable-next-line func-visibility\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 _initialSupply\n  ) ERC20(name, symbol) {\n    _mint(msg.sender, _initialSupply);\n    initialSupply = _initialSupply;\n  }\n\n  function totalSupply() public view override returns (uint256) {\n    return (initialSupply * multiplier) / _precision;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public override returns (bool) {\n    _checkBalance(from);\n    _checkBalance(to);\n    return super.transferFrom(from, to, amount);\n  }\n\n  function transfer(address to, uint256 amount) public override returns (bool) {\n    _checkBalance(msg.sender);\n    _checkBalance(to);\n    return super.transfer(to, amount);\n  }\n\n  function _checkBalance(address _account) private {\n    uint256 _multiplier = multiplier - userMultipliers[_account] - _precision;\n    if (_multiplier > 0) {\n      uint256 _amount = (super.balanceOf(_account) * _multiplier) / _precision;\n      _mint(_account, _amount);\n      userMultipliers[_account] += _multiplier;\n    }\n  }\n\n  function balanceOf(address _account) public view override returns (uint256) {\n    uint256 _multiplier = multiplier - userMultipliers[_account];\n    return (super.balanceOf(_account) * _multiplier) / _precision;\n  }\n\n  function increaseSupply(uint256 _multiplier) public onlyOwner {\n    multiplier += _multiplier;\n    emit IncreaseSupply(multiplier, _multiplier);\n  }\n}\n"
    },
    "contracts/fixed-supply-token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n@dev An implementation of the ERC20 contract which has a fixed TotalSupply at creation time\n*/\ncontract FixSupplyToken is ERC20 {\n  // solhint-disable-next-line func-visibility\n  constructor(\n    string memory name,\n    string memory symbol,\n    address[] memory _initialHolders,\n    uint256[] memory _initialBalances\n  ) ERC20(name, symbol) {\n    require(_initialHolders.length == _initialBalances.length, \"arrays must have same lenght\");\n    for (uint256 i = 0; i < _initialHolders.length; i++) {\n      _mint(_initialHolders[i], _initialBalances[i]);\n    }\n  }\n}\n"
    },
    "contracts/original-trove-factory.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"./trove-factory.sol\";\n\ncontract OriginalTroveFactory is TroveFactory {\n  function name() public view override returns (string memory) {\n    return \"Original Factory\";\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}